<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>LOSM Presentation</title>

		<meta name="description" content="Presentation for Linked OpenStreetMap demo">
		<meta name="author" content="Vito Walter Anelli, Pasquale Galeone">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/sisinf.css">
		<link rel="stylesheet" href="css/theme/sky.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>
<img src="img/poliba_logo.png" class="upperleft" alt="logo Poliba" />
<img src="img/logosisinf.png" class="upperright" alt="logo SisinfLab" />
<div class="upperdivider"></div>
<div class="lowerdivider"></div>
		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>LOSM</h1>
					<h3>Linked Open Street Map</h3>
					<p>
						<small>A new service to query OpenstreetMap through a clear Sparql endpoint.</small>
					</p>
<p>
						<small>Supervisors: <a href="http://sisinflab.poliba.it/PISCITELLI/">Prof. Giacomo Piscitelli</a> &amp; <a href="http://sisinflab.poliba.it/dinoia/">Prof. Tommaso di Noia</a></small>
					<br />
						<small style="font-size:0.5em;">Created by <a href="mailto:vitowalteranelli@gmail.com">Vito Walter Anelli</a> &amp; <a href="mailto:galeone85@gmail.com">Pasquale Galeone</a></small>
					</p>
					<aside class="notes">
						Oh hey, these are some notes. They'll be hidden in your presentation, but you can see them if you open the speaker notes window (hit 's' on your keyboard).
					</aside>
				</section>

				<section>
					<h2>Intro</h2>
					<p>
						The LOD role: 
					</p>
					<ul>
					<li>Linked Open Data is ceaselessly growing</li>
					<li>Deep Web is maybe bigger but not linked</li>
					</ul>
					<aside class="notes">
						La produzione e l’utilizzo dei Linked Open Data (LOD) sta profondamente influenzando sia le prospettive che
le scelte progettuali nello sviluppo di servizi ed applicazioni Web. Le vaste potenzialità dell’utilizzo e dell’analisi di tali dati sono tuttavia fortemente limitate dalla scarsa disponibilità di risorse georeferenziate. Il progetto OpenStreetMap (OSM), d’altro canto, continua a crescere rendendo disponibili, attraverso le proprie API, una enorme mole di dati geografici a prima vista inutilizzabile nell’ambito del Web Semantico.
					</aside>
				</section>

				<section>
					<h2>Some figures</h2>
					<ul>
						<li>LOD CLOUD: 50 billion RDF triples [2] [3]</li>
						<li>DBpedia (LOD): 3 billion RDF triples [4]</li>
						<li>OpenStreetMap (not LOD): 4.8 billion of nodes [5]</li>

					</ul>
				</section>

				<section>
					<h2>RDF stands for:</h2>
					<ul>
						<li><b>R</b>esource:<font style="font-size:0.7em;">  a resource is identified by a unique URI</font></li>
						<li><b>D</b>escription:<font style="font-size:0.7em;">  properties and relations of the resources</font></li>
						<li><b>F</b>ramework:<font style="font-size:0.7em;">  a set of languages and models describing inner and outer relationships</font></li>

					</ul>
				</section>


				<section data-markdown>
					<h2>Sparql 1.1</h2>
					<script type="text/template">
						## Sparql 1.1
						<b>SPARQL</b> <b>P</b>rotocol <b>a</b>nd <b>R</b>DF <b>Q</b>uery <b>L</b>anguage <br />
						Example:

						```
						
						 SELECT * WHERE {
						 ?movie a <http://dbpedia.org/ontology/Film> .
						 ?movie <http://dbpedia.org/ontology/country> 
						 <http://it.dbpedia.org/resource/Italia> .
						}
						
						```
					</script>
					<aside class="notes">
						è un elemento chiave del web semantico e permette di estrarre informazioni dalle basi di conoscenza distribuite sul web. RDF descrive i concetti e le relazioni su essi attraverso l’introduzione di triple e consente una rappresentazione della conoscenza più adatta all'elaborazione automatica delle informazioni e l'utilizzo di modelli informativi più flessibili e meno vincolati[32].
					</aside>
				</section>

				<!--<section>
					<h2>Sparql 1.1</h2>
					
						<b>SPARQL</b> <b>P</b>rotocol <b>a</b>nd <b>R</b>DF <b>Q</b>uery <b>L</b>anguage <br />
						Example:
						<pre><code>
SELECT * WHERE {
?movie a &lt;http://dbpedia.org/ontology/Film&gt; .
?movie &lt;http://dbpedia.org/ontology/country&gt; 
&lt;http://it.dbpedia.org/resource/Italia&gt; .
}
						</code></pre>
					<aside class="notes">
						è un elemento chiave del web semantico e permette di estrarre informazioni dalle basi di conoscenza distribuite sul web. RDF descrive i concetti e le relazioni su essi attraverso l’introduzione di triple e consente una rappresentazione della conoscenza più adatta all'elaborazione automatica delle informazioni e l'utilizzo di modelli informativi più flessibili e meno vincolati[32].
					</aside>
				</section>-->


				<section>
					<h2>OpenStreetMap</h2>
					<ul>
						<li>“Wikipedia of Maps”</li>
						<li>Editable by anyone with an account</li>
						<li>Data available to anyone, for free</li>

					</ul>
					<aside class="notes">

						OpenStreetMap (OSM) è un progetto collaborativo finalizzato a creare mappe del mondo a contenuto libero, cioè senza licenza di copyright. Il progetto punta ad una raccolta mondiale dei dati geografici, con scopo principale la creazione di mappe e cartografie.
						La rappresentazione del mondo fisico in OpenStreetMap è basata su quattro elementi: Nodes, Ways, Relations, Tags [38].

					</aside>
				</section>

				<section>
					<h2>Overpass API</h2>
					<ul>
						<li>“Give the data back to the people”</li>
						<li>lower the barrier for reusing OSM-data</li>
						<li>quick filtering and search of data</li>
						<li>easy exporting of data</li>
						<li>query by Tag and Tag/Value</li>
						<li>query by timestamp and user</li>
						<li>search in region</li>

					</ul>
					<aside class="notes">
						Overpass API sono delle API read-only che mettono a disposizione porzioni di dati georeferenziati di OpenStreetMap. Consentono di ricercare nodi nella forma <br />
						node.a[amenity=foo];
http://slides.com/martinraifer/overpass-turbo-en/fullscreen#
					</aside>
				</section>

				<section>
					<h2>GeoSparql</h2>
					<ul>
						<li>Provide a common target for implementers and users</li>
						<li>Simple enough for general users but capable enough for GIS professionals</li>
						<li>Accomodate systems based on qualitative spatial reasoning and systems based on quantitative geometries</li>

					</ul>
					<aside class="notes">
						Lo standard OGC GeoSPARQL[28] supporta la rappresentazione e l'interrogazione dei dati geospaziali sul Semantic Web. GeoSPARQL definisce un vocabolario per la rappresentazione di dati geospaziali in RDF, e definisce una un'estensione al linguaggio di query SPARQL per l'elaborazione di dati geospaziali.
tratto da OGC GeoSparql: standardizing spatial query on the semantic web, 4th annual spatial ontology community of practice workshop 2011 Reston VA M. Perry Oracle
http://slideplayer.com/slide/697652/
					</aside>
				</section>


				<section>
					<h2>Apache Jena Spatial</h2>
						<ul style="font-size:0.7em;">
						<li>?place spatial:nearby (latitude, longitude, radius [, units, limit])</li>
						<li>?place spatial:withinCircle (latitude, longitude, radius [, units, limit])	</li>
						<li>?place spatial:withinBox (latitude_min, longitude_min, latitude_max, longitude_max [, limit])	</li>
						<li>?place spatial:intersectBox (latitude_min, longitude_min, latitude_max, longitude_max [, limit])	</li>
						<li>?place spatial:north (latitude, longitude [, limit])	Query for the ?place northing the location of (latitude, longitude).</li>
						<li>?place spatial:south (latitude, longitude [, limit])	Query for the ?place southing the location of (latitude, longitude).</li>
						<li>?place spatial:west (latitude, longitude [, limit])	Query for the ?place westing the location of (latitude, longitude).</li>
						<li>?place spatial:east (latitude, longitude [, limit])</li>
						</ul>
					<aside class="notes">
						Questa iniziativa mira ad implementare, come estensione di Jena ARQ, alcune semplici interrogazioni spaziali in SPARQL. Jena spatial è stato concepito per ricercare Linked data che siano "vicini" ad un determinato punto [42].
					</aside>
				</section>



				<section>
					<h2>LinkedGeoData</h2>
						<ul style="font-size:0.7em;">
						<li>Key-Value pairs will be assigned to RDF resources</li>
						<li>Each pair (k v) can be annotated with datatypes, language tags, classes</li>
						<li>Mappings are themselves tables</li>
						</ul>
					<img src="img/lgdtable.png" style="height:6em;border:0;box-shadow:none;background:none;" alt="architecture" />
					<aside class="notes">
					LinkedGeoData è un progetto che si propone di integrare il web dei dati con i dati disponibili su
OpenStreetMap.Per realizzare questo obiettivo i progettisti hanno dovuto raggiungere diversi compromessi.
					</aside>
				</section>


				<section id="fragments">
					<h2>LOSM implementation</h2>
					<ul>
						<li class="fragment">Architecture</li>
						<li class="fragment">Grammar</li>
						<li class="fragment">Geosparql Functions</li>
						<li class="fragment">Server
							<ul>
								<li class="fragment">Scanner</li>
								<li class="fragment">Parser</li>
								<li class="fragment">Translation</li>
							</ul></li>
						<li class="fragment">Client</li>

					</ul>
				</section>

				<section id="fragments4">
					<h2 class="fragment fade-out">Architecture</h2>
					<img class="fragment grow" src="img/architettura.png" style="height:10em;border:0;box-shadow:none;background:none;" alt="architecture" />
				</section>

				<section>
					<section>
						<h2>Grammar</h2>
						<p style="font-size:0.7em;">The productions for terminals were fully implemented as described in <a target=_blank href="http://www.w3.org/TR/sparql11-query/#sparqlGrammar"> sparql specifications</a></p>
						<p style="font-size:0.7em;">The productions for non-terminals listed <a target=_blank href="http://sisinflab.poliba.it/semanticweb/lod/losm/losm_grammar.html"> here</a> are a modified subset of the standard sparql ones.
It is a modified subset basically for two reasons: <br />
<ul style="font-size:0.7em;">
						<li> A reduced grammar has to be modified to be consistent </li>
						<li> We inserted Parameter and ParameterList productions to get parameters of jena spatial function using the same way as GeoSparql does.</li>
</ul>
						<br />
						<a href="#" class="navigate-down">
							<img width="17" style="border:0;box-shadow:none;background:none;" height="23" data-src="https://s3.amazonaws.com/hakim-static/reveal-js/arrow.png" alt="Down arrow">
						</a>
					</section>
					<section>
						<h2>Grammar</h2>
						<div style="font-size:0.4em;
    display: block;
    position: relative;
    //width: 50em; 
    height: 25em;
    margin: 20px auto;
    text-align: left;
    font-family: monospace;
    line-height: 1.2em;
    word-wrap: break-word;
    overflow: auto;
    box-shadow: 0px 0px 6px rgba(0, 0, 0, 0.3);
    background: #3F3F3F;
    color: #DCDCDC;" class="">
<table>
						    <tbody>
						        <tr valign="baseline">
						            <td><code>[1]&nbsp;&nbsp;</code></td>
						            <td><code>QueryUnit</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>Query <span class="token"></span></code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[2]&nbsp;&nbsp;</code></td>
						            <td><code>Query</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>Prologue SelectQuery?</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[3]&nbsp;&nbsp;</code></td>
						            <td><code>UpdateUnit</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>Update <span class="token"></span></code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[4]&nbsp;&nbsp;</code></td>
						            <td><code>Prologue</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>( BaseDecl | PrefixDecl )*</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[5]&nbsp;&nbsp;</code></td>
						            <td><code>BaseDecl</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code><span class="token">'BASE'</span> IRIREF</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[6]&nbsp;&nbsp;</code></td>
						            <td><code>PrefixDecl</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code><span class="token">'PREFIX'</span> PNAME_NS IRIREF</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[7]&nbsp;&nbsp;</code></td>
						            <td><code>SelectQuery</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>SelectClause WhereClause SolutionModifier</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[8]&nbsp;&nbsp;</code></td>
						            <td><code>SubSelect</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>SelectClause WhereClause SolutionModifier</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[9]&nbsp;&nbsp;</code></td>
						            <td><code>SelectClause</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code><span class="token">'SELECT'</span> <span class="token">'DISTINCT'</span>? ( ( Var | ( <span class="token">'('</span> Expression <span class="token">'AS'</span> Var <span class="token">')'</span> ) )+ | <span class="token">'*'</span> )</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[17]&nbsp;&nbsp;</code></td>
						            <td><code>WhereClause</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code><span class="token">'WHERE'</span>? GroupGraphPattern</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[18]&nbsp;&nbsp;</code></td>
						            <td><code>SolutionModifier</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>OrderClause? LimitOffsetClauses?</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[23]&nbsp;&nbsp;</code></td>
						            <td><code>OrderClause</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code><span class="token">'ORDER'</span> <span class="token">'BY'</span> OrderCondition+</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[24]&nbsp;&nbsp;</code></td>
						            <td><code>OrderCondition</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>   ( ( <span class="token">'ASC'</span> | <span class="token">'DESC'</span> ) BrackettedExpression )<br>| ( Constraint | Var ) </code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[25]&nbsp;&nbsp;</code></td>
						            <td><code>LimitOffsetClauses</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>LimitClause OffsetClause? | OffsetClause LimitClause? </code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[26]&nbsp;&nbsp;</code></td>
						            <td><code>LimitClause</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code><span class="token">'LIMIT'</span> INTEGER</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[27]&nbsp;&nbsp;</code></td>
						            <td><code>OffsetClause</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code><span class="token">'OFFSET'</span> INTEGER</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[53]&nbsp;&nbsp;</code></td>
						            <td><code>GroupGraphPattern</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code><span class="token">'{'</span> ( SubSelect | GroupGraphPatternSub ) <span class="token">'}'</span></code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[54]&nbsp;&nbsp;</code></td>
						            <td><code>GroupGraphPatternSub</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>TriplesBlock? ( GraphPatternNotTriples <span class="token">'.'</span>? TriplesBlock? )*</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[55]&nbsp;&nbsp;</code></td>
						            <td><code>TriplesBlock</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>TriplesSameSubjectPath ( <span class="token">'.'</span> TriplesBlock? )?</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[56]&nbsp;&nbsp;</code></td>
						            <td><code>GraphPatternNotTriples</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>GroupOrUnionGraphPattern | Filter</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[67]&nbsp;&nbsp;</code></td>
						            <td><code>GroupOrUnionGraphPattern</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>GroupGraphPattern ( <span class="token">'UNION'</span> GroupGraphPattern )*</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[68]&nbsp;&nbsp;</code></td>
						            <td><code>Filter</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code><span class="token">'FILTER'</span> Constraint</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[69]&nbsp;&nbsp;</code></td>
						            <td><code>Constraint</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>BrackettedExpression | BuiltInCall | FunctionCall</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[70]&nbsp;&nbsp;</code></td>
						            <td><code>FunctionCall</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>iri ArgList</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[71]&nbsp;&nbsp;</code></td>
						            <td><code>ArgList</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>NIL | <span class="token">'('</span> <span class="token">'DISTINCT'</span>? Expression ( <span class="token">','</span> Expression )* <span class="token">')'</span> </code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[72]&nbsp;&nbsp;</code></td>
						            <td><code>ExpressionList</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>NIL | <span class="token">'('</span> Expression ( <span class="token">','</span> Expression )* <span class="token">')'</span> </code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[77]&nbsp;&nbsp;</code></td>
						            <td><code>PropertyListNotEmpty</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>Verb ObjectList ( <span class="token">';'</span> ( Verb ObjectList )? )*</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[78]&nbsp;&nbsp;</code></td>
						            <td><code>Verb</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>VarOrIri | <span class="token">'a'</span></code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[79]&nbsp;&nbsp;</code></td>
						            <td><code>ObjectList</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>Object ( <span class="token">','</span> Object )*</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[80]&nbsp;&nbsp;</code></td>
						            <td><code>Object</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>GraphNode</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[81]&nbsp;&nbsp;</code></td>
						            <td><code>TriplesSameSubjectPath</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>VarOrTerm PropertyListPathNotEmpty |	TriplesNodePath PropertyListPath</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[82]&nbsp;&nbsp;</code></td>
						            <td><code>PropertyListPath</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>PropertyListPathNotEmpty?</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[__]&nbsp;&nbsp;</code></td>
						            <td><code>ParametersList</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>( Parameter* )</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[__]&nbsp;&nbsp;</code></td>
						            <td><code>Parameter</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>NumericLiteral | Var | String</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[83]&nbsp;&nbsp;</code></td>
						            <td><code>PropertyListPathNotEmpty</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>( VerbPath | VerbSimple ) ( ObjectListPath | ParametersList ) ( <span class="token">';'</span> ( ( VerbPath | VerbSimple ) ObjectList )? )*</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[84]&nbsp;&nbsp;</code></td>
						            <td><code>VerbPath</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>Path</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[85]&nbsp;&nbsp;</code></td>
						            <td><code>VerbSimple</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>Var</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[86]&nbsp;&nbsp;</code></td>
						            <td><code>ObjectListPath</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>ObjectPath ( <span class="token">','</span> ObjectPath )*</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[87]&nbsp;&nbsp;</code></td>
						            <td><code>ObjectPath</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>GraphNodePath</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[88]&nbsp;&nbsp;</code></td>
						            <td><code>Path</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>PathAlternative</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[89]&nbsp;&nbsp;</code></td>
						            <td><code>PathAlternative</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>PathSequence ( <span class="token">'|'</span> PathSequence )*</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[90]&nbsp;&nbsp;</code></td>
						            <td><code>PathSequence</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>PathEltOrInverse ( <span class="token">'/'</span> PathEltOrInverse )*</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[91]&nbsp;&nbsp;</code></td>
						            <td><code>PathElt</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>PathPrimary PathMod?</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[92]&nbsp;&nbsp;</code></td>
						            <td><code>PathEltOrInverse</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>PathElt | <span class="token">'^'</span> PathElt</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[93]&nbsp;&nbsp;</code></td>
						            <td><code>PathMod</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code><span class="token">'?'</span> | <span class="token">'*'</span> | <span class="token">'+'</span></code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[94]&nbsp;&nbsp;</code></td>
						            <td><code>PathPrimary</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>iri | <span class="token">'a'</span> | <span class="token">'!'</span> PathNegatedPropertySet | <span class="token">'('</span> Path <span class="token">')'</span> </code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[95]&nbsp;&nbsp;</code></td>
						            <td><code>PathNegatedPropertySet</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>PathOneInPropertySet | <span class="token">'('</span> ( PathOneInPropertySet ( <span class="token">'|'</span> PathOneInPropertySet )* )? <span class="token">')'</span> </code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[96]&nbsp;&nbsp;</code></td>
						            <td><code>PathOneInPropertySet</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>iri | <span class="token">'a'</span> | <span class="token">'^'</span> ( iri | <span class="token">'a'</span> ) </code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[97]&nbsp;&nbsp;</code></td>
						            <td><code>Integer</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>INTEGER</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[98]&nbsp;&nbsp;</code></td>
						            <td><code>TriplesNode</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>Collection |	BlankNodePropertyList</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[99]&nbsp;&nbsp;</code></td>
						            <td><code>BlankNodePropertyList</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code><span class="token">'['</span> PropertyListNotEmpty <span class="token">']'</span></code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[100]&nbsp;&nbsp;</code></td>
						            <td><code>TriplesNodePath</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>CollectionPath |	BlankNodePropertyListPath</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[101]&nbsp;&nbsp;</code></td>
						            <td><code>BlankNodePropertyListPath</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code><span class="token">'['</span> PropertyListPathNotEmpty <span class="token">']'</span></code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[102]&nbsp;&nbsp;</code></td>
						            <td><code>Collection</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code><span class="token">'('</span> GraphNode+ <span class="token">')'</span></code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[103]&nbsp;&nbsp;</code></td>
						            <td><code>CollectionPath</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code><span class="token">'('</span> GraphNodePath+ <span class="token">')'</span></code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[104]&nbsp;&nbsp;</code></td>
						            <td><code>GraphNode</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>VarOrTerm |	TriplesNode</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[105]&nbsp;&nbsp;</code></td>
						            <td><code>GraphNodePath</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>VarOrTerm |	TriplesNodePath</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[106]&nbsp;&nbsp;</code></td>
						            <td><code>VarOrTerm</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>Var | GraphTerm</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[107]&nbsp;&nbsp;</code></td>
						            <td><code>VarOrIri</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>Var | iri</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[108]&nbsp;&nbsp;</code></td>
						            <td><code>Var</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>VAR1 | VAR2</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[109]&nbsp;&nbsp;</code></td>
						            <td><code>GraphTerm</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>iri |	RDFLiteral |	NumericLiteral |	BooleanLiteral |	BlankNode |	NIL</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[110]&nbsp;&nbsp;</code></td>
						            <td><code>Expression</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>ConditionalOrExpression</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[111]&nbsp;&nbsp;</code></td>
						            <td><code>ConditionalOrExpression</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>ConditionalAndExpression ( <span class="token">'||'</span> ConditionalAndExpression )*</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[112]&nbsp;&nbsp;</code></td>
						            <td><code>ConditionalAndExpression</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>ValueLogical ( <span class="token">'&amp;&amp;'</span> ValueLogical )*</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[113]&nbsp;&nbsp;</code></td>
						            <td><code>ValueLogical</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>RelationalExpression</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[114]&nbsp;&nbsp;</code></td>
						            <td><code>RelationalExpression</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>NumericExpression ( <span class="token">'='</span> NumericExpression | <span class="token">'!='</span> NumericExpression | <span class="token">'&lt;'</span> NumericExpression | <span class="token">'&gt;'</span> NumericExpression | <span class="token">'&lt;='</span> NumericExpression | <span class="token">'&gt;='</span> NumericExpression | <span class="token">'IN'</span> ExpressionList | <span class="token">'NOT'</span> <span class="token">'IN'</span> ExpressionList )?</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[115]&nbsp;&nbsp;</code></td>
						            <td><code>NumericExpression</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>AdditiveExpression</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[116]&nbsp;&nbsp;</code></td>
						            <td><code>AdditiveExpression</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>MultiplicativeExpression ( <span class="token">'+'</span> MultiplicativeExpression | <span class="token">'-'</span> MultiplicativeExpression | ( NumericLiteralPositive | NumericLiteralNegative ) ( ( <span class="token">'*'</span> UnaryExpression ) | ( <span class="token">'/'</span> UnaryExpression ) )* )*</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[117]&nbsp;&nbsp;</code></td>
						            <td><code>MultiplicativeExpression</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>UnaryExpression ( <span class="token">'*'</span> UnaryExpression | <span class="token">'/'</span> UnaryExpression )*</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[118]&nbsp;&nbsp;</code></td>
						            <td><code>UnaryExpression</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>&nbsp;&nbsp;<span class="token">'!'</span> PrimaryExpression <br>|	<span class="token">'+'</span> PrimaryExpression <br>|	<span class="token">'-'</span> PrimaryExpression <br>|	PrimaryExpression</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[119]&nbsp;&nbsp;</code></td>
						            <td><code>PrimaryExpression</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>BrackettedExpression | BuiltInCall | iriOrFunction | RDFLiteral | NumericLiteral | BooleanLiteral | Var</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[120]&nbsp;&nbsp;</code></td>
						            <td><code>BrackettedExpression</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code><span class="token">'('</span> Expression <span class="token">')'</span></code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[121]&nbsp;&nbsp;</code></td>
						            <td><code>BuiltInCall</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>&nbsp;&nbsp;Aggregate <br>|	<span class="token">'STR'</span> <span class="token">'('</span> Expression <span class="token">')'</span> <br>|	<span class="token">'COALESCE'</span> ExpressionList <br>|	<span class="token">'IF'</span> <span class="token">'('</span> Expression <span class="token">','</span> Expression <span class="token">','</span> Expression <span class="token">')'</span> <br>|	<span class="token">'STRLANG'</span> <span class="token">'('</span> Expression <span class="token">','</span> Expression <span class="token">')'</span> <br>|	<span class="token">'STRDT'</span> <span class="token">'('</span> Expression <span class="token">','</span> Expression <span class="token">')'</span> <br>|	<span class="token">'sameTerm'</span> <span class="token">'('</span> Expression <span class="token">','</span> Expression <span class="token">')'</span> <br>|	<span class="token">'isIRI'</span> <span class="token">'('</span> Expression <span class="token">')'</span> <br>|	<span class="token">'isURI'</span> <span class="token">'('</span> Expression <span class="token">')'</span> <br>|	<span class="token">'isBLANK'</span> <span class="token">'('</span> Expression <span class="token">')'</span> <br>|	<span class="token">'isLITERAL'</span> <span class="token">'('</span> Expression <span class="token">')'</span> <br>|	<span class="token">'isNUMERIC'</span> <span class="token">'('</span> Expression <span class="token">')'</span> <br>|	RegexExpression</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[122]&nbsp;&nbsp;</code></td>
						            <td><code>RegexExpression</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code><span class="token">'REGEX'</span> <span class="token">'('</span> Expression <span class="token">','</span> Expression ( <span class="token">','</span> Expression )? <span class="token">')'</span></code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[123]&nbsp;&nbsp;</code></td>
						            <td><code>SubstringExpression</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code><span class="token">'SUBSTR'</span> <span class="token">'('</span> Expression <span class="token">','</span> Expression ( <span class="token">','</span> Expression )? <span class="token">')'</span></code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[124]&nbsp;&nbsp;</code></td>
						            <td><code>StrReplaceExpression</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code><span class="token">'REPLACE'</span> <span class="token">'('</span> Expression <span class="token">','</span> Expression <span class="token">','</span> Expression ( <span class="token">','</span> Expression )? <span class="token">')'</span></code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[127]&nbsp;&nbsp;</code></td>
						            <td><code>Aggregate</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>&nbsp;&nbsp;<span class="token">'COUNT'</span> <span class="token">'('</span> <span class="token">'DISTINCT'</span>? ( <span class="token">'*'</span> | Expression ) <span class="token">')'</span> <br>| <span class="token">'SUM'</span> <span class="token">'('</span> <span class="token">'DISTINCT'</span>? Expression <span class="token">')'</span> <br>| <span class="token">'MIN'</span> <span class="token">'('</span> <span class="token">'DISTINCT'</span>? Expression <span class="token">')'</span> <br>| <span class="token">'MAX'</span> <span class="token">'('</span> <span class="token">'DISTINCT'</span>? Expression <span class="token">')'</span> <br>| <span class="token">'AVG'</span> <span class="token">'('</span> <span class="token">'DISTINCT'</span>? Expression <span class="token">')'</span> <br>| <span class="token">'GROUP_CONCAT'</span> <span class="token">'('</span> <span class="token">'DISTINCT'</span>? Expression ( <span class="token">';'</span> <span class="token">'SEPARATOR'</span> <span class="token">'='</span> String )? <span class="token">')'</span> </code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[128]&nbsp;&nbsp;</code></td>
						            <td><code>iriOrFunction</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>iri ArgList?</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[129]&nbsp;&nbsp;</code></td>
						            <td><code>RDFLiteral</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>String ( <span class="token">'^^'</span> iri )?</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[130]&nbsp;&nbsp;</code></td>
						            <td><code>NumericLiteral</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>NumericLiteralUnsigned | NumericLiteralPositive | NumericLiteralNegative</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[131]&nbsp;&nbsp;</code></td>
						            <td><code>NumericLiteralUnsigned</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>INTEGER |	DECIMAL |	DOUBLE</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[132]&nbsp;&nbsp;</code></td>
						            <td><code>NumericLiteralPositive</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>INTEGER_POSITIVE |	DECIMAL_POSITIVE |	DOUBLE_POSITIVE</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[133]&nbsp;&nbsp;</code></td>
						            <td><code>NumericLiteralNegative</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>INTEGER_NEGATIVE |	DECIMAL_NEGATIVE |	DOUBLE_NEGATIVE</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[134]&nbsp;&nbsp;</code></td>
						            <td><code>BooleanLiteral</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code><span class="token">'true'</span> |	<span class="token">'false'</span></code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[135]&nbsp;&nbsp;</code></td>
						            <td><code>String</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>STRING_LITERAL1 | STRING_LITERAL2 | STRING_LITERAL_LONG1 | STRING_LITERAL_LONG2</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[136]&nbsp;&nbsp;</code></td>
						            <td><code>iri</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>IRIREF |	PrefixedName</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[137]&nbsp;&nbsp;</code></td>
						            <td><code>PrefixedName</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>PNAME_LN | PNAME_NS</code></td>
						        </tr>
						        <tr valign="baseline">
						            <td><code>[138]&nbsp;&nbsp;</code></td>
						            <td><code>BlankNode</code></td>
						            <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
						            <td><code>BLANK_NODE_LABEL |	ANON</code></td>
						        </tr>
						    </tbody>
						</table>
</div>
				</section>
				</section>
			<section>
				<section>
						<h2>Scanner</h2>
				</section>
				<section data-transition="fade">	
						<h2>Scanner<h2>
						<img src="img/scanner.png" style="padding-left: 25px;border:0;box-shadow:none;background:none;" alt="scanner" />
				</section>
			</section>
			<section>
					<h2>JFLEX</h2>
					<img src="img/jflex.png" style="border:0;box-shadow:none;background:none;" alt="jflex" />
			</section>			
			<section>
				<section>
					<h2 style="text-transform: none;">Sparql.lex</h2>
					<ul>
						<li class="fragment fade-in">CODE SECTION</li>
						<li class="fragment fade-in">DECLARATIONS SECTION</li> 
						<li class="fragment fade-in">RULES SECTION</li>
					</ul>
					<!--<br>
						<a href="#" class="navigate-down" padding-top="10px">
							 <img width="17" height="23" data-src="https://s3.amazonaws.com/hakim-static/reveal-js/arrow.png" alt="Down arrow">
						</a>-->
				</section>
				<section>
						<h3>CODE SECTION</h3>
							<pre><code style="font-size:0.9em;">
package sparql;
import java_cup.runtime.*;
							</pre></code>
				</section>
				<section>
						<h3>DECLARATIONS SECTION</h3>
							<pre><code style="font-size:0.7em;">
%public
%class SparqlLexer
%cupsym SparqlSym
%cup
%function next_token
...
public String getWord(){return yytext();}
public int getLine(){return yyline+1;}
public int getCurrentPos(){return zzCurrentPos;}
...
INTEGER = [0-9]+
INTEGER_POSITIVE = "+"{INTEGER}
...
BASE = [bB][aA][sS][eE]
PREFIX = [pP][rR][eE][fF][iI][xX]
SELECT = [sS][eE][lL][eE][cC][tT]
...
							</pre></code>
				</section>
				<section>
						<h3>RULES SECTION</h3>
							<pre><code style="font-size:0.7em;">
&lt;YYINITIAL&gt; {
{PLX} { return new Symbol(SparqlSym.PLX, yytext()); }
/* keywords */
{BASE} { return new Symbol(SparqlSym.BASE, yytext()); }
{PREFIX} { return new Symbol(SparqlSym.PREFIX, yytext()); }
{SELECT} { return new Symbol(SparqlSym.SELECT, yytext()); }
...
}
							</pre></code>
				</section>					
			</section>
			<section>
				<section>
					<h2>Parser</h2>
				</section>
				<section data-transition="fade">
					<h2>Parser</h2>
						<img src="img/parser.png" style="height:10em;border:0;box-shadow:none;background:none;" alt="parser" />
				</section>
			</section>			
			<section>
				<h2>CUP</h2>
					<img src="img/cup.png" style="border:0;box-shadow:none;background:none;" alt="cup" />
			</section>		
			<section>
					<section>
					<h2 style="text-transform: none;">Sparql.cup</h2>
					<ul>
						<li class="fragment fade-in">Package and import Specifications</li>
						<li class="fragment fade-in">User Code Components</li>
						<li class="fragment fade-in">Symbol Lists</li>
						<li class="fragment fade-in">Precedences and Associativity Declarations</li>
						<li class="fragment fade-in">Grammar</li>
					</ul>
					</section>
					<section>
						<p>Package and import Specifications</p>
							<pre><code style="font-size:0.9em;">
import java.io.*;
import java_cup.runtime.*;
import java.util.*;
import java_cup.runtime.Symbol;
							</pre></code>
					</section>
					<section>
						<p>User Code Components</p>
							<pre><code style="font-size:0.7em;">
action code{:
    Map&lt;String , ArrayList&lt;CoarseTriple&gt;&gt; sky = new HashMap&lt;&gt;();
    ArrayList&lt;FakeError&gt; selectVarsTot= new ArrayList&lt;FakeError&gt;();
    ArrayList&lt;FakeError&gt; whereVarsTot= new ArrayList&lt;FakeError&gt;();
    ArrayList&lt;FakeError&gt; solutionVarsTot= new ArrayList&lt;FakeError&gt;();
    ArrayList&lt;String&gt; selectVarsStr= new ArrayList&lt;String&gt;();
    ArrayList&lt;String&gt; whereVarsStr= new ArrayList&lt;String&gt;();
    ArrayList&lt;String&gt; solutionVarsStr= new ArrayList&lt;String&gt;();
    ArrayList&lt;FakeError&gt; wherePreTot= new ArrayList&lt;FakeError&gt;();
    ArrayList&lt;FakeError&gt; prefixPreTot= new ArrayList&lt;FakeError&gt;();
    ArrayList&lt;String&gt; wherePreStr= new ArrayList&lt;String&gt;();
    ArrayList&lt;String&gt; prefixPreStr= new ArrayList&lt;String&gt;();
    ArrayList&lt;FakeError&gt; tempTot= new ArrayList&lt;FakeError&gt;();
    ArrayList&lt;String&gt; tempStr= new ArrayList&lt;String&gt;();
    ArrayList&lt;FakeError&gt; tempPreTot= new ArrayList&lt;FakeError&gt;();
    ArrayList&lt;String&gt; tempPreStr= new ArrayList&lt;String&gt;();
:};

parser code {:
    public Map&lt;String , ArrayList&lt;String&gt;&gt; getResults(){
		return totalResults;
  	}
    
    public static Map&lt;String , ArrayList&lt;String&gt;&gt; totalResults;
    private ArrayList&lt;String&gt; errorList =new ArrayList&lt;String&gt;();
    public static int errors = 0;
    SparqlLexer scan= (SparqlLexer)this.getScanner();
    int lastErrorLine;
    int lastErrorColumn;
    String lastErrorWord;
    String lastErrorBuffer;
    int lastPos;
    String lastLineString;
	
	public String buildLine(String lastErrorBuffer,int lastPos){
    	System.out.println(lastPos+"buffer:"+lastErrorBuffer.length());
	    int end = lastErrorBuffer.indexOf("\n",lastPos);
	    String sub =lastErrorBuffer.substring(0,lastPos);
	    int start = sub.lastIndexOf("\n")+1;
	    System.out.println("start:"+start+"end:"+end);
	    if (start&lt;0){start=0;}
    return lastErrorBuffer.substring(start,end);
    }
    
    public void syntax_error(Symbol cur_token) {
     	lastErrorLine =  scan.getLine();
     	lastErrorColumn = scan.getColumn();
     	lastErrorWord = scan.getWord();
     	lastErrorBuffer = new String(scan.getBuffer());
     	lastPos = scan.getCurrentPos();
     	lastLineString = buildLine(lastErrorBuffer,lastPos);
		System.out.println("I am sorry, but I have to ");
		System.out.println("report a syntax error.");
		System.out.println("The last symbol was: "+ scan.getWord());
		System.out.println("at line number " + scan.getLine());
    }
    
    public int getNoErrors(){
    return errorList.size();
    }
    public ArrayList&lt;String&gt; getErrors(){
    return errorList;
    }
    public void run(){
		MapMan manager = new MapMan(action_obj.sky);
		totalResults = manager.go();
    }
    
    public void report_error(String message, Object info) {
		StringBuffer m = new StringBuffer();
		if (info instanceof FakeError){
		     FakeError info2 = (FakeError)info;
		     m.append("Error "+"( line: "+info2.getLine());
			 m.append(" column: "+info2.getColumn());
			 m.append(" lexeme: "+info2.getWord());
			 m.append(" ): Syntax Error\n");
			 m.append(" "+(errorList.size()+1)+" :");
			 m.append(" "+message+"\n");
		    }
		 	else {
			 	m.append("Error "+"( line: "+lastErrorLine);
			 	m.append(" column: "+lastErrorColumn);
			 	m.append(" lexeme: "+lastErrorWord);
			 	m.append(" ): Syntax Error\n");
			 	m.append(" "+(errorList.size()+1)+" :");
			 	m.append(" "+message+"\n");
		    }
		    System.err.println(m);
		    m = new StringBuffer();
		    if (info instanceof FakeError){
		    	FakeError info2 = (FakeError)info;
		     	m.append("Error "+"( line: "+info2.getLine());
			    m.append(" column: "+info2.getColumn());
			    m.append(" lexeme: "+info2.getWord());
			    m.append(" ): Syntax Error\n");
			    m.append("&lt;br /&gt;");
			    m.append(" "+(errorList.size()+1)+" :");
			    m.append(" "+message+"\n");
			    m.append("&lt;br /&gt;");
		   		}
		    	else {
			    	m.append("Error "+"( line: "+lastErrorLine);
			    	m.append(" column: "+lastErrorColumn);
			    	m.append(" lexeme: "+lastErrorWord);
			    	m.append(" ): Syntax Error\n");
			    	m.append("&lt;br /&gt;");
			    	m.append(" "+(errorList.size()+1)+" :");
			    	m.append(" "+message+"\n");
			    	m.append("&lt;br /&gt;");
		    	}
		    errorList.add(m.toString());
	} 
:}
					</pre></code>
					</section>
					<section>
						<p>Symbol Lists</p>
							<pre><code style="font-size:0.7em;">					
terminal String	BASE , PREFIX , SELECT , CONSTRUCT , DESCRIBE , ASK , ORDER , BY , DESC , LIMIT , OFFSET , DISTINCT , REDUCED , FROM , NAMED , WHERE , GRAPH , OPTIONAL , UNION , FILTER , ISA , STR , LANG , LANGMATCHES , DATATYPE , BOUND , SAMETERM , ISURI , ISIRI , ISBLANK , ISLITERAL , REGEX , TRUE , FALSE, NOT , EXISTS , REPLACE , AS , SUBSTR , BNODE , IRI , URI , RAND , ABS , CEIL , FLOOR , ROUND , CONCAT , STRLEN , UCASE , LCASE , ENCODE_FOR_URI , CONTAINS , STRSTARTS , STRENDS , STRBEFORE , STRAFTER , YEAR , MONTH , DAY , HOURS , MINUTES , SECONDS , TIMEZONE , TZ , UUID , STRUUID , MD5 , SHA1 , SHA256 , SHA384 , SHA512 , COALESCE , IF , STRLANG , ISNUMERIC , HAVING , VALUES  , SILENT   , SERVICE , BIND , UNDEF , MINUS , GROUP_CONCAT , SUM , MIN , MAX , COUNT , SAMPLE , AVG , SEPARATOR;
terminal String STRDT, NOW, IN, CARET, ASC, GROUP, PARENTHO, PARENTHC, SBRACKETO, SBRACKETC, CBRACKETO, CBRACKETC, EMARK, STAR, DOT, COMMA, SEMICOLON , CARETCARET, PIPE, SLASH, QMARK, DOUBLEPIPE, DOUBLEAMPERSAND, EQUALMARK, LT, GT, DIFFERENT, LEQUAL, GEQUAL, PLUSMARK, MINUSMARK;
terminal String PN_PREFIX, CREATE,VARNAME, INTO,PN_LOCAL_ESC, ADD,PN_CHARS_U, OPERATOR, MOVE, USING,PN_CHARS_BASE,EXPONENT, DROP, DELETE,PN_LOCAL,PLX,PERCENT,HEX,PN_CHARS, CLEAR     , COPY , TO , INSERT , DATA  , WITH  , ALL, LOAD, DEFAULT,ECHAR;
terminal String IRIREF,PNAME_NS,PNAME_LN,BLANK_NODE_LABEL,VAR1,VAR2,LANGTAG,INTEGER,DECIMAL,DOUBLE,INTEGER_POSITIVE,DECIMAL_POSITIVE,DOUBLE_POSITIVE,INTEGER_NEGATIVE,DECIMAL_NEGATIVE,DOUBLE_NEGATIVE,STRING_LITERAL1,STRING_LITERAL2,STRING_LITERAL_LONG1,STRING_LITERAL_LONG2,NIL,WS,ANON;

non terminal FineElement    ObjectPaths, GraphOrTriples, LimitClauseQ,  Prologue ;
non terminal FineElement    BaseDecl , PrefixDecl ,BaseORPreS,BaseORPres,BaseORPre, SelectQuery , SubSelect ;
non terminal FineElement    WhereClause , SolutionModifier ;
non terminal FineElement    OrderClause , OrderCondition , LimitOffsetClauses  ;
non terminal FineElement    LimitClause , OffsetClause , GroupGraphPattern , GroupGraphPatternSub  ;
non terminal FineElement    GraphPatternNotTriples ;
non terminal FineElement    GroupOrUnionGraphPattern , Filter , Constraint , FunctionCall , ArgList , ExpressionList ;
non terminal FineElement    Verb , ObjectList , Object  ;
non terminal FineElement    VerbPath , VerbSimple , ObjectListPath , ObjectPath , Path , PathAlternative , PathSequence  ;
non terminal FineElement    PathElt , PathEltOrInverse , PathMod , PathPrimary , PathNegatedPropertySet , PathOneInPropertySet  , TriplesNode  ;
non terminal FineElement    BlankNodePropertyList , TriplesNodePath , BlankNodePropertyListPath , Collection , CollectionPath , GraphNode  ;
non terminal FineElement 	GraphNodePath , VarOrIri  , GraphTerm , Expression , ConditionalOrExpression , ConditionalAndExpression  ;
non terminal FineElement    ValueLogical , RelationalExpression , NumericExpression , AdditiveExpression , MultiplicativeExpression, NumericLiteralUnary, NumericLiteralBoth  ;
non terminal FineElement    UnaryExpression , PrimaryExpression , BrackettedExpression , BuiltInCall , RegexExpression , SubstringExpression  ;
non terminal FineElement    StrReplaceExpression , Aggregate , iriOrFunction , RDFLiteral , NumericLiteral  ;
non terminal FineElement    NumericLiteralUnsigned , NumericLiteralPositive , NumericLiteralNegative , BooleanLiteral , String , iri  ;
non terminal FineElement    PrefixedName , BlankNode , VarOrExpression ;
non terminal FineElement    WHEREQ, OrderClauseQ, LimitOffsetClausesQ ;
non terminal FineElement    OrderConditionP, OffsetClauseQ, TriplesBlockQ ;
non terminal FineElement    DISTINCTQ, ExpressionS,Expressions, VerbObjQ, VerbObjQS,VerbObjQs, ObjS,Objs ; 
non terminal FineElement    VerbPathORSimple, VerbPathObjQ,VerbPathObj, VerbPathObjQS,VerbPathObjQs, ObjectPathS, PathSequenceS, PathSequences, PathEltOrInverseS, PathEltOrInverses, PathModQ ;
non terminal FineElement    PathOneInPropertySetS, PathOneInPropertySetSQ, PathOneInPropertySets, GraphNodeP, GraphNodePathP, ConditionalAndExpressionS, ConditionalAndExpressions ;
non terminal FineElement    ValueLogicalS, ValueLogicals, UnaryExpressionOR, UnaryExpressionORS, UnaryExpressionORs, NumericUnary, MultiplicativeORExpression ;
non terminal FineElement    MultiplicativeORExpressionS, MultiplicativeORExpressions;
non terminal CoarseTriple   PropertyListPath  ,ParameterList, ParameterS, Parameters, TriplesSameSubjectPath,TriplesBlock ;
non terminal FineElement    Var, VarOrTerm, Parameter;
non terminal FineElement    PropertyListNotEmpty ;
non terminal CoarseTriple   PropertyListPathNotEmpty, PropertyListPathNotEmptyQ;
non terminal ArrayList&lt;FineElement&gt;    VarOrExpressions,SelectClause;
non terminal String         QueryUnit, Query, BaseDeclQ, PrefixDeclS,PrefixDecls ;
							</pre></code>
					</section>
					<section>
						<p>Precedences and Associativity Declarations</p>
							<pre><code style="font-size:0.7em;">
precedence nonassoc SELECT;
precedence left CBRACKETO,CBRACKETC;
precedence left SBRACKETO,SBRACKETC;
precedence nonassoc STR, SAMETERM, ISURI, ISIRI, ISBLANK, ISLITERAL, REGEX, REPLACE, SUBSTR, BNODE, IRI;
precedence nonassoc URI, RAND, ABS, CEIL, FLOOR, ROUND, CONCAT, STRLEN, UCASE, LCASE, ENCODE_FOR_URI, CONTAINS;
precedence nonassoc STRSTARTS, STRENDS, STRBEFORE, STRAFTER, YEAR, MONTH, DAY, HOURS, MINUTES, SECONDS, TIMEZONE;
precedence nonassoc TZ, UUID, STRUUID, MD5, SHA1, SHA256, SHA384, SHA512, COALESCE, IF, STRLANG, ISNUMERIC;
precedence nonassoc GROUP_CONCAT, SUM, MIN, MAX, COUNT, AVG, STRDT, NOW, EMARK;
precedence left PARENTHO,PARENTHC;
precedence left EQUALMARK, DIFFERENT, LT, GT, LEQUAL, GEQUAL, NOT, IN;
precedence nonassoc DOUBLEAMPERSAND;
precedence nonassoc COMMA;
precedence nonassoc SEMICOLON;
precedence nonassoc PIPE;
precedence nonassoc SLASH;
precedence left PLUSMARK, MINUSMARK;
precedence left STAR, SLASH;
precedence nonassoc STRING_LITERAL_LONG1, STRING_LITERAL_LONG2;
precedence nonassoc IRIREF, PNAME_NS, PNAME_LN, VAR1, VAR2, INTEGER, DECIMAL, DOUBLE, STRING_LITERAL1, STRING_LITERAL2;
precedence nonassoc INTEGER_POSITIVE,DECIMAL_POSITIVE,DOUBLE_POSITIVE,INTEGER_NEGATIVE,DECIMAL_NEGATIVE,DOUBLE_NEGATIVE;
precedence nonassoc TRUE, FALSE;
							</pre></code>
					</section>
					<section>
						<p>Grammar</p>
							<pre><code style="font-size:0.7em;">
start with QueryUnit;

  	QueryUnit	  ::=  	Query
         {: 
			System.out.println("parsing done!");
			
			System.out.println("\n");
			Iterator iterator = sky.keySet().iterator();
  
				while (iterator.hasNext()) {
				   String key = iterator.next().toString();
				   String value = sky.get(key).toString();
				   System.out.println(key + " " + value);
			}
			
			
			RESULT=new String("exit");
			
			if (selectVarsStr.size()!=0){System.out.println("selectVars: "+selectVarsStr.toString());}			
			if (whereVarsStr.size()!=0){System.out.println("whereVars: "+whereVarsStr.toString());}
			if (solutionVarsStr.size()!=0){System.out.println("solutionVars: "+solutionVarsStr.toString());}
			Iterator iteratorVars = selectVarsStr.iterator();
  
			while (iteratorVars.hasNext()) {
				   String value = (String)iteratorVars.next();
				   if (whereVarsStr.contains(value)){
				   }else{
							   
						 parser.report_error("Error in SelectClause: "+value+" is not in WhereClause", selectVarsTot.get(selectVarsStr.indexOf(value)) ); 
						 System.out.println("Error in SelectClause: "+value+" is not in WhereClause");
				   }
			}
			iteratorVars = solutionVarsStr.iterator();
  
			while (iteratorVars.hasNext()) {
				   String value = (String)iteratorVars.next();
				   if (whereVarsStr.contains(value)){
				   }else{
							   
						 parser.report_error("Error in SolutionModifier: "+value+" is not in WhereClause", solutionVarsTot.get(solutionVarsStr.indexOf(value)) );
						 System.out.println("Error in SolutionModifier: "+value+" is not in WhereClause");
				   }
			}
			
					
			if (wherePreStr.size()!=0){System.out.println("wherePreStr: "+wherePreStr.toString());}
			if (prefixPreStr.size()!=0){System.out.println("prefixPreStr: "+prefixPreStr.toString());}
			iteratorVars = wherePreStr.iterator();
  
			while (iteratorVars.hasNext()) {
				   String value = (String)iteratorVars.next();
				   if (prefixPreStr.contains(value)){
				   }else{
							   
						 parser.report_error("Error in WhereClause: "+value+" has not declared in Prologue", wherePreTot.get(wherePreStr.indexOf(value)) ); 
						 System.out.println("Error in WhereClause: "+value+" has not declared in Prologue");
				   }
			}
         :}|
         {: 
		     SparqlLexer scan= (SparqlLexer)CUP$SparqlCup$parser.getScanner();
			FakeError nut = new FakeError(scan.getLine(),scan.getColumn(),scan.getWord(),scan.getCurrentPos(),scan.getBuffer());
			 parser.report_error("Error in QueryUnit, Query expected", nut );
			System.out.println("Error in QueryUnit");
         :} ;  

  	Query	  ::=  	Prologue SelectQuery
         {: 
			System.out.println("Query");
			
         :} 
         |
         Prologue
         {: 
		     SparqlLexer scan= (SparqlLexer)CUP$SparqlCup$parser.getScanner();
			 FakeError nut = new FakeError(scan.getLine(),scan.getColumn(),scan.getWord(),scan.getCurrentPos(),scan.getBuffer());
			 parser.report_error("Error in Query, SelectQuery expected", nut );
			System.out.println("Error in Query");
         :} 
         | SelectQuery
         {: 
			System.out.println("Query");
         :}
         ;  
         
         Prologue	  ::=  	BaseORPreS
         {: 
			System.out.println("Prologue");
			
			
			prefixPreTot = new ArrayList&lt;FakeError&gt;(tempPreTot);
			prefixPreStr = new ArrayList&lt;String&gt;(tempPreStr);
			tempPreTot  = new ArrayList&lt;FakeError&gt;();
			tempPreStr  = new ArrayList&lt;String&gt;();
         :};  
         
         BaseORPre  ::= BaseDecl
         |
         PrefixDecl
         |  
         error:e
         {: 
			 parser.report_error("Error in Prologue, BASE or PREFIX expected", e );
			System.out.println("Error in Prologue");

         :}
         ;
         
         BaseORPreS  ::= BaseORPres
         ;
         
         BaseORPres  ::=  BaseORPre
         |
         BaseORPre BaseORPres
         ;
   
  	BaseDecl	  ::=  	BASE IRIREF
         {: 
			System.out.println("BaseDecl");

         :}| BASE error:e
         {: 
			 parser.report_error("Error in BaseDecl, IRIREF expected", e );
			System.out.println("Error in BaseDecl");

         :} ;  
 
  	PrefixDecl	  ::=  	PREFIX PNAME_NS:a IRIREF
         {: 
			System.out.println("prefix block");
			
            if (tempPreStr.contains(a.toString())){
            
            }
            else {
            
		     	SparqlLexer scan= (SparqlLexer)CUP$SparqlCup$parser.getScanner();
				FakeError nut = new FakeError(scan.getLine(),scan.getColumn(),scan.getWord(),scan.getCurrentPos(),scan.getBuffer());
            	tempPreTot.add(nut);
            	tempPreStr.add(a.toString());
            	System.out.println("prefix vector updated");
            }
         :}
         | 
         PREFIX error:e
         {: 
			 parser.report_error("Error in PREFIX, PNAME_NS expected", e );
			System.out.println("Error in PREFIX");

         :} 
         | 
         PREFIX PNAME_NS:a error:e
         {: 
			 parser.report_error("Error in PREFIX, IRIREF expected", e );
			System.out.println("Error in PREFIX");
			
            if (tempPreStr.contains(a.toString())){
            
            }
            else {
            
		     	SparqlLexer scan= (SparqlLexer)CUP$SparqlCup$parser.getScanner();
				FakeError nut = new FakeError(scan.getLine(),scan.getColumn(),scan.getWord(),scan.getCurrentPos(),scan.getBuffer());
            	tempPreTot.add(nut);
            	tempPreStr.add(a.toString());
            	System.out.println("prefix vector updated");
            }

         :}  
         ;  



  	SelectQuery	  ::=  	 
         SelectClause WhereClause SolutionModifier
         {: 
			System.out.println("SelectQuery");
			
			
         :}  
         |
         SelectClause WhereClause error:e
         {: 
			 parser.report_error("Error in SolutionModifier, OrderClause error", null );
			System.out.println("Error in SolutionModifier");
			
         :}   
         |
         SelectClause WhereClause
         {: 
			System.out.println("SelectQuery");
			
         :}  
         |
         SelectClause error:e 
         {: 
			parser.report_error("Error in SelectQuery, WhereClause missing", null );
			System.out.println("EError in SelectQuery, WhereClause missing");
			
         :} SolutionModifier
            | 
         WhereClause error:e
         {: 
			parser.report_error("Error in SelectQuery, SelectClause missing", null );
			System.out.println("Error in SelectQuery, SelectClause missing");
			
			
         :} 
          |  WhereClause SolutionModifier
         {: 
		    SparqlLexer scan= (SparqlLexer)CUP$SparqlCup$parser.getScanner();
			FakeError nut = new FakeError(scan.getLine(),scan.getColumn(),scan.getWord(),scan.getCurrentPos(),scan.getBuffer());
			parser.report_error("Error in SelectQuery, SelectClause missing", nut );
			System.out.println("Error in SelectQuery, SelectClause missing");
			
			
         :}
         |
         SelectClause error:e
         {: 
			 parser.report_error("Error in SelectQuery, WhereClause error", null );
			System.out.println("EError in SelectQuery, WhereClause error");
			
         :} 
       
         |	
  		SelectClause 
         {: 
			 parser.report_error("Error in SelectQuery, WhereClause error", null );
			System.out.println("EError in SelectQuery, WhereClause error");
			
         :}         
      
                  
         | WhereClause
         
         {: 
		    SparqlLexer scan= (SparqlLexer)CUP$SparqlCup$parser.getScanner();
			FakeError nut = new FakeError(scan.getLine(),scan.getColumn(),scan.getWord(),scan.getCurrentPos(),scan.getBuffer());
			parser.report_error("Error in SelectQuery, SelectClause missing", nut );
			System.out.println("Error in SelectQuery, SelectClause missing");
			
			
         :} 
         ;  








  	SubSelect	  ::=  	SelectClause WhereClause SolutionModifier
         {: 
			System.out.println("SubSelect");

         :} 
         ;  


  	SelectClause	  ::=  	SELECT DISTINCT  VarOrExpressions:a
         {: 
         	ArrayList&lt;FineElement&gt; exitvalue = new ArrayList&lt;FineElement&gt;();
			exitvalue.addAll(a);
			ResultMap.selectList = exitvalue;
			selectVarsTot = new ArrayList&lt;FakeError&gt;(tempTot);
			selectVarsStr = new ArrayList&lt;String&gt;(tempStr);
			tempTot  = new ArrayList&lt;FakeError&gt;();
			tempStr  = new ArrayList&lt;String&gt;();

         :} 
         ;  
         
	VarOrExpressions  ::=   VarOrExpression:a
	 {: 
	 		ArrayList&lt;FineElement&gt; exitvalue = new ArrayList&lt;FineElement&gt;();
	 		exitvalue.add(a);
	 		RESULT=exitvalue;

         :} 
         ;
         
	VarOrExpressions  ::=  VarOrExpression:b VarOrExpressions:a 
	 {: 
			ArrayList&lt;FineElement&gt; exitvalue = new ArrayList&lt;FineElement&gt;();
			exitvalue.addAll(a);
			exitvalue.add(b);
	 		RESULT=exitvalue;
         :} 
         ; 
          
	VarOrExpression   ::=   Var:a
	 {: 
			System.out.println("VarOrExpression: "+a.getContent());
			RESULT=new FineElement(a);

         :} 
         ;
         
	VarOrExpression   ::=   PARENTHO Expression AS Var PARENTHC
	 {: 
			System.out.println("VarOrExpression");

         :} 
         ;

  	SelectClause	  ::=  	SELECT:e DISTINCT  STAR 
         {: 
				System.out.println("SelectClause");
			selectVarsTot = new ArrayList&lt;FakeError&gt;(tempTot);
			selectVarsStr = new ArrayList&lt;String&gt;(tempStr);
			tempTot  = new ArrayList&lt;FakeError&gt;();
			tempStr  = new ArrayList&lt;String&gt;();
         :} 
         ;  

  	SelectClause	  ::=  	SELECT VarOrExpressions:a
         {: 
         	ArrayList&lt;FineElement&gt; exitvalue = new ArrayList&lt;FineElement&gt;();
			exitvalue.addAll(a);
			ResultMap.selectList = exitvalue;
			selectVarsTot = new ArrayList&lt;FakeError&gt;(tempTot);
			selectVarsStr = new ArrayList&lt;String&gt;(tempStr);
			tempTot  = new ArrayList&lt;FakeError&gt;();
			tempStr  = new ArrayList&lt;String&gt;();

         :} 
         ;  

  	SelectClause	  ::=  	SELECT STAR
         {: 
			System.out.println("SelectClause");
			
			selectVarsTot = new ArrayList&lt;FakeError&gt;(tempTot);
			selectVarsStr = new ArrayList&lt;String&gt;(tempStr);
			tempTot  = new ArrayList&lt;FakeError&gt;();
			tempStr  = new ArrayList&lt;String&gt;();
         :} 
         ;
         
    SelectClause	  ::=  	SELECT error:e
         {: 
			 parser.report_error("Error in SelectClause, vars or star expected", null );
			System.out.println("Error in SelectClause");
			
			selectVarsTot = new ArrayList&lt;FakeError&gt;(tempTot);
			selectVarsStr = new ArrayList&lt;String&gt;(tempStr);
			tempTot  = new ArrayList&lt;FakeError&gt;();
			tempStr  = new ArrayList&lt;String&gt;();
         :} 
         ;  

  	WhereClause	  ::=  	WHERE:ww  GroupGraphPattern
         {: 
         	System.out.println(ww);
			System.out.println("WhereClause");
			
			whereVarsTot = new ArrayList&lt;FakeError&gt;(tempTot);
			whereVarsStr = new ArrayList&lt;String&gt;(tempStr);
			tempTot  = new ArrayList&lt;FakeError&gt;();
			tempStr  = new ArrayList&lt;String&gt;();
			wherePreTot = new ArrayList&lt;FakeError&gt;(tempPreTot);
			wherePreStr = new ArrayList&lt;String&gt;(tempPreStr);
			tempPreTot  = new ArrayList&lt;FakeError&gt;();
			tempPreStr  = new ArrayList&lt;String&gt;();
         :} 
         |
          GroupGraphPattern
         {: 
			System.out.println("WhereClause");
			
			whereVarsTot = new ArrayList&lt;FakeError&gt;(tempTot);
			whereVarsStr = new ArrayList&lt;String&gt;(tempStr);
			tempTot  = new ArrayList&lt;FakeError&gt;();
			tempStr  = new ArrayList&lt;String&gt;();
			wherePreTot = new ArrayList&lt;FakeError&gt;(tempPreTot);
			wherePreStr = new ArrayList&lt;String&gt;(tempPreStr);
			tempPreTot  = new ArrayList&lt;FakeError&gt;();
			tempPreStr  = new ArrayList&lt;String&gt;();
         :}  
        |
         WHERE:ww  error:e
         {: 
             System.out.println(ww);
			 parser.report_error("Error in WhereClause, GroupGraphPattern error in brackets", null );
			 System.out.println("Error in GroupGraphPattern");
			
			whereVarsTot = new ArrayList&lt;FakeError&gt;(tempTot);
			whereVarsStr = new ArrayList&lt;String&gt;(tempStr);
			tempTot  = new ArrayList&lt;FakeError&gt;();
			tempStr  = new ArrayList&lt;String&gt;();
			wherePreTot = new ArrayList&lt;FakeError&gt;(tempPreTot);
			wherePreStr = new ArrayList&lt;String&gt;(tempPreStr);
			tempPreTot  = new ArrayList&lt;FakeError&gt;();
			tempPreStr  = new ArrayList&lt;String&gt;();
         :} ;  
         
         
	WHEREQ            ::=   WHERE
         {: 
				System.out.println("WHEREQ");
	
         :} 
         |
         ;  


  	SolutionModifier	  ::=  	OrderClause LimitOffsetClauses
         {: 
			System.out.println("SolutionModifier");
			
			solutionVarsTot = new ArrayList&lt;FakeError&gt;(tempTot);
			solutionVarsStr = new ArrayList&lt;String&gt;(tempStr);
			tempTot  = new ArrayList&lt;FakeError&gt;();
			tempStr  = new ArrayList&lt;String&gt;();
         :}
         |
         	OrderClause 
         {: 
			System.out.println("SolutionModifier");
			
			solutionVarsTot = new ArrayList&lt;FakeError&gt;(tempTot);
			solutionVarsStr = new ArrayList&lt;String&gt;(tempStr);
			tempTot  = new ArrayList&lt;FakeError&gt;();
			tempStr  = new ArrayList&lt;String&gt;();

         :}
         |
         	LimitOffsetClauses
         {: 
			System.out.println("SolutionModifier");
			solutionVarsTot = new ArrayList&lt;FakeError&gt;(tempTot);
			solutionVarsStr = new ArrayList&lt;String&gt;(tempStr);
			tempTot  = new ArrayList&lt;FakeError&gt;();
			tempStr  = new ArrayList&lt;String&gt;();

         :} 
         |
         	OrderClause error:e
         {: 
			 parser.report_error("Error in SolutionModifier, LimitOffsetClauses error", null );
			System.out.println("Error in SolutionModifier");
			
			solutionVarsTot = new ArrayList&lt;FakeError&gt;(tempTot);
			solutionVarsStr = new ArrayList&lt;String&gt;(tempStr);
			tempTot  = new ArrayList&lt;FakeError&gt;();
			tempStr  = new ArrayList&lt;String&gt;();
         :}
         ;  
	OrderClauseQ      ::=   OrderClause
         {: 
			System.out.println("OrderClauseQ");

         :} 
         |
         ;  
	LimitOffsetClausesQ  ::=  LimitOffsetClauses
         {: 
			System.out.println("LimitOffsetClausesQ");

         :} 
         |
         ;  


  	OrderClause	  ::=  	ORDER BY OrderConditionP
         {: 
			System.out.println("OrderClause");

         :} 
         |
          ORDER BY  error:e
         {: 
			 parser.report_error("Error in OrderClause, OrderCondition error", null );
			System.out.println("Error in OrderClause");
         :} 
         |
          ORDER  error:e
         {: 
			 parser.report_error("Error in OrderClause, OrderCondition error", null );
			System.out.println("Error in OrderClause");
         :} 
         |
          ORDER  OrderConditionP
         {: 
			 parser.report_error("Error in OrderClause, BY missing", null );
			System.out.println("Error in OrderClause");
         :} 
         |
         BY OrderConditionP
         {: 
			 parser.report_error("Error in OrderClause, ORDER missing", null );
			System.out.println("Error in OrderClause");

         :}
         |
          error:e BY OrderConditionP
         {: 
			 parser.report_error("Error in OrderClause, ORDER wrong", null );
			System.out.println("Error in OrderClause");

         :} ;  
         
	OrderConditionP    ::=   OrderCondition
         {: 
			System.out.println("OrderConditionP");

         :} ;  
	OrderConditionP    ::=  OrderCondition OrderConditionP 
         {: 
			System.out.println("OrderConditionP");

         :} ;  

  	OrderCondition	  ::=  	ASC BrackettedExpression 
         {: 
			System.out.println("OrderCondition");

         :} 
         | 	
         DESC BrackettedExpression 
         {: 
			System.out.println("OrderCondition");

         :} 
         |	
         Constraint 
         {: 
			System.out.println("OrderCondition");

         :} 
         |  	 
         Var 
         {: 
			System.out.println("OrderCondition");

         :}
         |
         ASC error:e 
         {: 
			 parser.report_error("Error in OrderCondition, BrackettedExpression error", null );
			System.out.println("Error in OrderCondition");

         :} 
         | 	
         DESC error:e  
         {: 
			 parser.report_error("Error in OrderCondition, BrackettedExpression error", null );
			System.out.println("Error in OrderCondition");

         :} 
         ;  

  	LimitOffsetClauses	  ::=  	LimitClause
         {: 
			System.out.println("LimitOffsetClauses");

         :} 
         |
         LimitClause OffsetClause
         {: 
			System.out.println("LimitOffsetClauses");

         :}
         |
         OffsetClause
         {: 
			System.out.println("LimitOffsetClauses");

         :} 
         |
          OffsetClause LimitClause
         {: 
			System.out.println("LimitOffsetClauses");

         :}
         ;  
         
	OffsetClauseQ             ::=   OffsetClause
         {: 
			System.out.println("OffsetClauseQ");

         :} 
         |
         ;  
   
         
	LimitClauseQ              ::=   LimitClause
         {: 
			System.out.println("LimitClauseQ");

         :} 
         |
         ;  


  	LimitClause	  ::=  	LIMIT{: 
			System.out.println("LimitClause");
				
         :} INTEGER:i
         {: 
			System.out.println(i.toString());
				
         :} 
         |
         LIMIT
         {: 
		     SparqlLexer scan= (SparqlLexer)CUP$SparqlCup$parser.getScanner();
			FakeError nut = new FakeError(scan.getLine(),scan.getColumn(),scan.getWord(),scan.getCurrentPos(),scan.getBuffer());
			 parser.report_error("Error in LimitClause, LIMIT value missing", nut );
			System.out.println("Error in LimitClause");
				
         :} 
         |
         LIMIT error:e
         {: 
			 parser.report_error("Error in LimitClause, LIMIT value is not an integer", null );
			System.out.println("Error in LimitClause");
				
         :}
         ;  


  	OffsetClause	  ::=  	OFFSET INTEGER
         {: 
			System.out.println("OffsetClause");

         :} 
         |
         OFFSET error:e
         {: 
			 parser.report_error("Error in OffsetClause, OFFSET value is not an integer", null );
			System.out.println("Error in OffsetClause");

         :} 
         |
         OFFSET 
         {: 
		     SparqlLexer scan= (SparqlLexer)CUP$SparqlCup$parser.getScanner();
			FakeError nut = new FakeError(scan.getLine(),scan.getColumn(),scan.getWord(),scan.getCurrentPos(),scan.getBuffer());
			 parser.report_error("Error in OffsetClause, OFFSET value missing", nut );
			System.out.println("Error in OffsetClause");

         :} 
         ;  



  	GroupGraphPattern	  ::=  	CBRACKETO  SubSelect  
         {: 
			System.out.println("GroupGraphPattern");

         :} CBRACKETC
         |
           	CBRACKETO GroupGraphPatternSub:g  
         {: 
			System.out.println("GroupGraphPattern");
         :} CBRACKETC
         |
           	CBRACKETO error:e  
         {: 
            parser.report_error("Error in GroupGraphPattern, GroupGraphPatternSub or SubSelect wrong", null );
			System.out.println("Error in GroupGraphPattern");
         :} CBRACKETC
          |
           	CBRACKETO   CBRACKETC
         {: 
		     SparqlLexer scan= (SparqlLexer)CUP$SparqlCup$parser.getScanner();
			FakeError nut = new FakeError(scan.getLine(),scan.getColumn(),scan.getWord(),scan.getCurrentPos(),scan.getBuffer());
            parser.report_error("Error in GroupGraphPattern, GroupGraphPattern  empty", nut );
			System.out.println("Error in GroupGraphPattern");
         :}
        //prova 23 luglio la regola funziona ma con } group sbaglia la valutazione
         | 
         CBRACKETO  error:e
         {: 
            parser.report_error("Error in WhereClause closure", null );
			System.out.println("Error in WhereClause closure");
         :}
         
         ;  


  	GroupGraphPatternSub	  ::=   GraphOrTriples
         {: 
			System.out.println("GroupGraphPatternSub");

         :} 
         |
         TriplesBlock GraphOrTriples
         {: 
			System.out.println("GroupGraphPatternSub");

         :}
         |
         TriplesBlock 
         {: 
			System.out.println("GroupGraphPatternSub");

         :} ;  
         //ho sostituito nella seguente TriplesBlockQ con TriplesBlock
	GraphOrTriples ::= GraphOrTriples GraphPatternNotTriples DOT TriplesBlock
         {: 
			System.out.println("GraphOrTriples");

         :} 
         |
          GraphOrTriples GraphPatternNotTriples  TriplesBlock
         {: 
			System.out.println("GraphOrTriples");

         :} 
         | 
         GraphPatternNotTriples DOT TriplesBlock
         {: 
			System.out.println("GraphOrTriples");

         :} 
         | 
         GraphPatternNotTriples  TriplesBlock
         {: 
			System.out.println("GraphOrTriples");

         :} 
         ;  
         
         
	TriplesBlockQ  ::= TriplesBlock
         {: 
			System.out.println("TriplesBlockQ");
         :} 
         | 
         {: 
			System.out.println("finished");
         :} ;  

     	TriplesBlock	  ::=  	TriplesSameSubjectPath:a 
         {: 
         
			System.out.println("TRIPLESBLOCK2");
					    CoarseTriple exitvalue = new CoarseTriple();
		    exitvalue.addElement(a);
			System.out.println("TriplesBlock: "+exitvalue.toString());
			
			
			 if(sky.containsKey(exitvalue.get(0)))
			{
			ArrayList&lt;CoarseTriple&gt; modList = sky.get(exitvalue.get(0));
			modList.add(exitvalue);
			sky.put(exitvalue.get(0),modList);
			}else{
			ArrayList&lt;CoarseTriple&gt; listSameVar = new ArrayList&lt;CoarseTriple&gt;();
			listSameVar.add(exitvalue);
			sky.put(exitvalue.get(0),listSameVar);
			}
			RESULT=exitvalue;
         :}
         |
          TriplesSameSubjectPath:a  DOT:d 
         {: 
			
			System.out.println(d.toString());
		    CoarseTriple exitvalue = new CoarseTriple();
		    exitvalue.addElement(a);
			System.out.println("TriplesBlock: "+exitvalue.toString());
			
			
			 if(sky.containsKey(exitvalue.get(0)))
			{
			ArrayList&lt;CoarseTriple&gt; modList = sky.get(exitvalue.get(0));
			modList.add(exitvalue);
			sky.put(exitvalue.get(0),modList);
			}else{
			ArrayList&lt;CoarseTriple&gt; listSameVar = new ArrayList&lt;CoarseTriple&gt;();
			listSameVar.add(exitvalue);
			sky.put(exitvalue.get(0),listSameVar);
			}
			
			RESULT=exitvalue;
         :} 
         |
         TriplesSameSubjectPath:a   DOT:d TriplesBlock 
         {: 
         	
			System.out.println(d.toString());
			System.out.println("dotTRIPLESBLOCK");
			
		    CoarseTriple exitvalue = new CoarseTriple();
		    exitvalue.addElement(a);
			System.out.println("TriplesBlock: "+exitvalue.toString());
			
			
			 if(sky.containsKey(exitvalue.get(0)))
			{
			ArrayList&lt;CoarseTriple&gt; modList = sky.get(exitvalue.get(0));
			modList.add(exitvalue);
			sky.put(exitvalue.get(0),modList);
			}else{
			ArrayList&lt;CoarseTriple&gt; listSameVar = new ArrayList&lt;CoarseTriple&gt;();
			listSameVar.add(exitvalue);
			sky.put(exitvalue.get(0),listSameVar);
			}
			
			RESULT=exitvalue;
         :}
          ;  
         
  	GraphPatternNotTriples	  ::=  	GroupOrUnionGraphPattern
         {: 
			System.out.println("GraphPatternNotTriples");

         :} ;
         
	GraphPatternNotTriples	  ::=  	Filter
         {: 
			System.out.println("GraphPatternNotTriples");

         :} ;
         //modified
  	GroupOrUnionGraphPattern	  ::=  	GroupGraphPattern 
         {: 
			System.out.println("GroupOrUnionGraphPattern");

         :} ;  

		 
  	Filter	  ::=  	FILTER Constraint
         {: 
			System.out.println("Filter: Rule translation not supported in this Demo Version");
       

         :} ;  


  	Constraint	  ::=  	BrackettedExpression
         {: 
			System.out.println("Constraint: Rule translation not supported in this Demo Version");
       
         :} ;

	Constraint	  ::=  	BuiltInCall
         {: 
			System.out.println("Constraint: Rule translation not supported in this Demo Version");
       
         :} ;		 

	Constraint	  ::=  	FunctionCall
         {: 
			System.out.println("Constraint: Rule translation not supported in this Demo Version");
       
         :} ;

  	FunctionCall	  ::=  	iri ArgList
         {: 
			System.out.println("FunctionCall: Rule translation not supported in this Demo Version");
       :} ;  


  	ArgList	  ::=  	NIL
         {: 
			System.out.println("ArgList");

         :} ;

	ArgList	  ::=  	PARENTHO DISTINCTQ Expression ExpressionS PARENTHC
         {: 
			System.out.println("ArgList");

         :} ;
	DISTINCTQ ::= DISTINCT
         {: 
			System.out.println("DISTINCTQ");

         :} |;
    ExpressionS ::= Expressions
         |
         %prec COMMA;
         
	Expressions ::= COMMA Expression
         {: 
			System.out.println("ExpressionS");

         :}
         |   COMMA Expression Expressions
         {: 
			System.out.println("ExpressionS");

         :}
         | COMMA error:e 
         {: 
            parser.report_error("Error in Expressions, error in comma delimiter object", null );
			System.out.println("Error in Expressions");

         :} 
         |
           COMMA error:e  Expressions
         {: 
            parser.report_error("Error in Expressions, error in middle of comma delimiter object", null );
			System.out.println("Error in Expressions");

         :}
         ;
         
  	ExpressionList	  ::=  	NIL
         {: 
			System.out.println("ExpressionList");

         :} ;

	ExpressionList	  ::=  	PARENTHO Expression ExpressionS PARENTHC
         {: 
			System.out.println("ExpressionList");

         :} ;
         

  	PropertyListNotEmpty	  ::=  	Verb ObjectList
         {: 
			System.out.println("PropertyListNotEmpty");

         :}
         |
         Verb ObjectList VerbObjQS
         {: 
			System.out.println("PropertyListNotEmpty");

         :} ;  
	VerbObjQ  ::= Verb ObjectList
         {: 
			System.out.println("VerbObjQ");

         :} 
         ;
    VerbObjQS ::= VerbObjQs 
    	;
    
	VerbObjQs ::=   SEMICOLON VerbObjQ
         {: 
			System.out.println("VerbObjQS");

         :} 
         |
          SEMICOLON VerbObjQ VerbObjQs
         {: 
			System.out.println("VerbObjQS");

         :}
         | SEMICOLON error:e 
         {: 
            parser.report_error("Error in VerbObjQs, error in SEMICOLON delimiter object", null );
			System.out.println("Error in VerbObjQs");

         :} 
         |
           SEMICOLON error:e  VerbObjQs
         {: 
            parser.report_error("Error in VerbObjQs, error in middle of SEMICOLON delimiter object", null );
			System.out.println("Error in VerbObjQs");

         :}
         %prec SEMICOLON;
         
  	Verb	  ::=  	VarOrIri
         {: 
			System.out.println("Verb");

         :} ;

	Verb	  ::=  	ISA
         {: 
			System.out.println("Verb");

         :} ;

  	ObjectList	  ::=  	Object ObjS
         {: 
			System.out.println("ObjectList");

         :} ;
	ObjS ::=    Objs
		|		
         %prec COMMA; 
	
	Objs ::=  COMMA Object
         {: 
			System.out.println("ObjS");

         :} 
         |
         COMMA Object Objs
         {: 
			System.out.println("ObjS");

         :}
         | COMMA error:e 
         {: 
            parser.report_error("Error in Objs, error in COMMA delimiter object", null );
			System.out.println("Error in Objs");

         :} 
         |
           COMMA error:e  Objs
         {: 
            parser.report_error("Error in Objs, error in middle of COMMA delimiter object", null );
			System.out.println("Error in Objs");

         :} ;

  	Object	  ::=  	GraphNode
         {: 
			System.out.println("Object");

         :} ;

  	TriplesSameSubjectPath	  ::=  	VarOrTerm:a 
  	{: 
  
			System.out.println("TriplesSameSubjectPath: "+a.toString());
			System.out.println("TriplesSameSubjectPath first class");
         :} PropertyListPathNotEmpty:b
         {: 
	     CoarseTriple exitvalue = new CoarseTriple();
	     exitvalue.addElement(a);
	     exitvalue.addElement(b);
			System.out.println("TriplesSameSubjectPath: "+exitvalue.toString());
			System.out.println("TriplesSameSubjectPath second class");
			
		RESULT=exitvalue;
         
         :}
         | 	TriplesNodePath  
		{: 

			
			System.out.println("TriplesSameSubjectPath first class");
         :} PropertyListPath:a
         {: 

			System.out.println("PropertyListPathUP: "+a.toString());
	     CoarseTriple exitvalue = new CoarseTriple();
	     exitvalue.addElement(a);
		RESULT=exitvalue;
			System.out.println("TriplesSameSubjectPath second class");
         :} 
         | 
         TriplesNodePath  
		{: 

			
         :} error:e
         {: 
            parser.report_error("Error in TriplesSameSubjectPath, verbobject error", null );
			System.out.println("Error in TriplesSameSubjectPath");

         :}
         | 
         VarOrTerm:a  
		{: 

			System.out.println("TriplesSameSubjectPath: "+a.toString());
			System.out.println("TriplesSameSubjectPath first class");
			
         :} error:e
         {: 
            parser.report_error("Error in TriplesSameSubjectPath, verbobject error", null );
			System.out.println("Error in TriplesSameSubjectPath");

         :}
         | 
         VarOrTerm:a  
		{: 
		     SparqlLexer scan= (SparqlLexer)CUP$SparqlCup$parser.getScanner();
			FakeError nut = new FakeError(scan.getLine(),scan.getColumn(),scan.getWord(),scan.getCurrentPos(),scan.getBuffer());
            parser.report_error("Error in TriplesSameSubjectPath, just subject error", nut );
			System.out.println("Error in TriplesSameSubjectPath");
	        CoarseTriple exitvalue = new CoarseTriple();
	        exitvalue.addElement(a);
	        exitvalue.addElement(a);
			System.out.println("TriplesSameSubjectPath: "+exitvalue.toString());
			System.out.println("TriplesSameSubjectPath second class");
			
		    RESULT=exitvalue;
			
         :};

	PropertyListPath	  ::=  	PropertyListPathNotEmptyQ:a
         {: 
			System.out.println("PropertyListPath: "+a.toString());
	     CoarseTriple exitvalue = new CoarseTriple();
	     exitvalue.addElement(a);
		RESULT=exitvalue;

         :} ;  
	PropertyListPathNotEmptyQ ::=   PropertyListPathNotEmpty:a
         {: 
			System.out.println("PropertyListPathNotEmptyQ: "+a.toString());
	     CoarseTriple exitvalue = new CoarseTriple();
	     exitvalue.addElement(a);
		RESULT=exitvalue;

         :} 
         |
         ;  

//added for spatial
         
     ParameterList	  ::=  	PARENTHO ParameterS:a PARENTHC
     {: 
	     System.out.println("PropertyListPathNotEmpty: "+a.toString());
	     CoarseTriple exitvalue = new CoarseTriple();
	     exitvalue.addElement(a);
		RESULT=exitvalue;

         :} 
         ;
     ParameterS  ::= Parameters:a 
     	{: 
	     System.out.println("PropertyListPathNotEmpty: "+a.toString());
	     CoarseTriple exitvalue = new CoarseTriple();
	     exitvalue.addElement(a);
		RESULT=exitvalue;

         :} 
     	|
     	;         
         
     Parameters	  ::=  	Parameter:a  
     {: 
	     System.out.println("ParameterSsingle: "+a.toString());
	     CoarseTriple exitvalue = new CoarseTriple();
	     exitvalue.addElement(a);
		RESULT=exitvalue;

         :}
         |
         	Parameter:a
     {: 
	     System.out.println("ParameterS1: "+a.toString());
	     CoarseTriple exitvalue = new CoarseTriple();
	     exitvalue.addElement(a);
		RESULT=exitvalue;

         :} Parameters:b 
     {: 
	     System.out.println("ParameterS2: "+b.toString());
	     CoarseTriple exitvalue = new CoarseTriple();
	     exitvalue.addElement(a);
	     exitvalue.addElement(b);
		RESULT=exitvalue;

         :}
         | error:e 
         {: 
            parser.report_error("Error in Parameters", null );
			System.out.println("Error in Parameters");

         :} 
         |
           error:e  Parameters:b
         {: 
            parser.report_error("Error in Parameters, error in middle of Parameters", null );
			System.out.println("Error in Parameters");

         :}  ;
         
     Parameter	  ::=  	NumericLiteral:a
     {: 
	     System.out.println("Parameter: "+a.toString());
		RESULT=new FineElement(a);

         :} | Var:a
         {: 
	     System.out.println("Parameter: "+a.toString());
		RESULT=new FineElement(a);

         :} | String:a
         {: 
	     System.out.println("Parameter: "+a.toString());
		RESULT=new FineElement(a);

         :} ;
        
         
	PropertyListPathNotEmpty	  ::=  	VerbPathORSimple:a {: 
			System.out.println("PropertyListPathNotEmpty: "+a.toString());
		     CoarseTriple exitvalue = new CoarseTriple();
		     exitvalue.addElement(a);
			RESULT=exitvalue;

         :} ObjectListPath:b  {: 


         
			System.out.println("PropertyListPathNotEmpty: "+b.toString());
				
		     CoarseTriple exitvalue = new CoarseTriple();
		     exitvalue.addElement(a);
		     exitvalue.addElement(b);
			RESULT=exitvalue;
		     
         :}
         VerbPathObjQS
         {: 

			System.out.println("PropertyListPathNotEmpty");

         :}
         | VerbPathORSimple:a ParameterList:b  {: 

			System.out.println("PropertyListPathNotEmpty: "+b.toString());
				
		     CoarseTriple exitvalue = new CoarseTriple();
		     exitvalue.addElement(a);
		     exitvalue.addElement(b);
			RESULT=exitvalue;
			
			
         :} VerbPathObjQS
         {: 

			System.out.println("PropertyListPathNotEmpty");

         :} 
         |
         VerbPathORSimple:a error:e
         {: 
		     CoarseTriple exitvalue = new CoarseTriple();
		     exitvalue.addElement(a);
		     FineElement b = new FineElement("placeholder","WORD");
		     exitvalue.addElement(b);
            parser.report_error("Error in PropertyListPathNotEmpty, object or end of triple error", null );
			System.out.println("Error in PropertyListPathNotEmpty");
			
			RESULT=exitvalue;

         :}
         ;  
         
         
//added for spatial end
         
    VerbPathObjQS  ::= VerbPathObjQs
    	|
    	%prec SEMICOLON;
    	
	VerbPathObjQs     ::= SEMICOLON VerbPathObj 
         {: 
			System.out.println("VerbPathObjQS");

         :} 
         |
           SEMICOLON VerbPathObj VerbPathObjQs
         {: 
			System.out.println("VerbPathObjQS");

         :} 
         | SEMICOLON error:e 
         {: 
            parser.report_error("Error in VerbPathObjQs, error in semicolon delimiter object", null );
			System.out.println("Error in VerbPathObjQs");

         :} 
         |
           SEMICOLON error:e  VerbPathObjQs
         {: 
            parser.report_error("Error in VerbPathObjQs, error in middle of semicolon delimiter object", null );
			System.out.println("Error in VerbPathObjQs");

         :} ;  


    VerbPathObj      ::= VerbPathORSimple ObjectList
         {: 
			System.out.println("VerbPathObjQ");

         :} 
         ;  
	VerbPathORSimple  ::= VerbPath:a
         {: 
			System.out.println("VerbPathORSimple: "+a.toString());
			RESULT=new FineElement(a);

         :} 
		|
		 VerbSimple
         {: 
			System.out.println("VerbPathORSimple");

         :} ;  


  	VerbPath	  ::=  	Path:a
         {: 
			System.out.println("VerbPath: "+a.toString());
			RESULT=new FineElement(a);

         :} ;  


  	VerbSimple	  ::=  	Var
         {: 
			System.out.println("VerbSimple");

         :} ;  

	ObjectListPath	  ::=  	ObjectPath:a 
		{: 

         
			System.out.println("ObjectListPath: "+a.toString());
			RESULT=new FineElement(a);
         :} 
         |
         ObjectPath:a 
		{: 

         
			System.out.println("ObjectListPath: "+a.toString());
			RESULT=new FineElement(a);
         :} ObjectPathS
         {: 
			System.out.println("ObjectListPath");

         
         :} ;  
    ObjectPathS  ::= ObjectPaths
	    %prec COMMA;
	    
	ObjectPaths	  ::=  	COMMA ObjectPath 
         {: 
			System.out.println("ObjectPathS");

         :} 
         |
           COMMA ObjectPath ObjectPaths
         {: 
			System.out.println("ObjectPathS");

         :} 
         
         | COMMA error:e 
         {: 
            parser.report_error("Error in ObjectPaths, error in comma delimiter object", null );
			System.out.println("Error in ObjectPaths");

         :} 
         |
           COMMA error:e  ObjectPaths
         {: 
            parser.report_error("Error in ObjectPaths, error in middle of comma delimiter object", null );
			System.out.println("Error in ObjectPaths");

         :};  

  	ObjectPath	  ::=  	GraphNodePath:a
         {: 

         
			System.out.println("ObjectPath: "+a.toString());
			RESULT=new FineElement(a);
         :} ;  


  	Path	  ::=  	PathAlternative:a
         {: 
			System.out.println("Path: "+a.toString());
			RESULT=new FineElement(a);

         :} ;  


	PathAlternative	  ::=  	PathSequence:a 
	{: 
			System.out.println("PathAlternative: "+a.toString());
			RESULT=new FineElement(a);
         :} PathSequenceS
         {: 
			System.out.println("PathAlternative");
         
         :} ;  
    PathSequenceS ::= PathSequences
	    |
	    %prec PIPE;
         
	PathSequences  ::= PIPE PathSequence:a
         {: 
			System.out.println("PathSequenceS");

         :} 
         |
           PIPE PathSequence:a PathSequences:b
         {: 
			System.out.println("PathSequenceS");
         
         
         :} 
         | PIPE error:e 
         {: 
            parser.report_error("Error in PathSequences, error in pipe delimiter object", null );
			System.out.println("Error in PathSequences");

         :} 
         |
           PIPE error:e  PathSequences
         {: 
            parser.report_error("Error in PathSequences, error in middle of pipe delimiter object", null );
			System.out.println("Error in PathSequences");

         :};  


	PathSequence	  ::=  	PathEltOrInverse:a {: 

			System.out.println("PathSequence: "+a.toString());
			RESULT=new FineElement(a);
         :} PathEltOrInverseS:b
         {: 
			System.out.println("PathSequence");

         :} ;  
         
    PathEltOrInverseS  ::= PathEltOrInverses
    |
    %prec SLASH;
    
	PathEltOrInverses         ::=  SLASH PathEltOrInverse:a
         {: 
			System.out.println("PathEltOrInverseS");

         :}
         |
          SLASH PathEltOrInverse:b PathEltOrInverses:a
         {: 
			System.out.println("PathEltOrInverseS");

         :}
         | SLASH error:e 
         {: 
            parser.report_error("Error in PathEltOrInverses, error in slash delimiter object", null );
			System.out.println("Error in PathEltOrInverses");

         :} 
         |
           SLASH error:e  PathEltOrInverses:a
         {: 
            parser.report_error("Error in PathEltOrInverses, error in middle of slash delimiter object", null );
			System.out.println("Error in PathEltOrInverses");

         :} ;  


  	PathElt	  ::=  	PathPrimary:a
  	 {: 
			System.out.println("PathElt: "+a.toString());
			RESULT=new FineElement(a);

         :} PathModQ
         {: 
			System.out.println("PathElt");

         :} ;  
	PathModQ                  ::=   PathMod
         {: 
			System.out.println("PathModQ");

         :} 
         |
         ;
           


  	PathEltOrInverse	  ::=  	PathElt:a
         {: 
			System.out.println("PathEltOrInverse: "+a.toString());
			RESULT=new FineElement(a);

         :} ;

	PathEltOrInverse	  ::=  	CARET PathElt:a
         {: 
			System.out.println("PathEltOrInverse: "+a.toString());
			RESULT=new FineElement(a);

         :} ;

	PathMod	  ::=  	QMARK
         {: 
			System.out.println("PathMod");

         :} ;
		 
	PathMod	  ::=  	STAR
         {: 
			System.out.println("PathMod");

         :} ;
		 
	PathMod	  ::=  	PLUSMARK
         {: 
			System.out.println("PathMod");

         :} ;

  	PathPrimary	  ::=  	iri:a
         {: 
			System.out.println("PathPrimary: "+a.toString());
			RESULT=new FineElement(a);

         :} ;

	PathPrimary	  ::=  	ISA:a
         {: 
			System.out.println("PathPrimary: "+a.toString());
			RESULT=new FineElement(a.toString(),"WORD");

         :} ;
	
	PathPrimary	  ::=  	EMARK PathNegatedPropertySet
         {: 
			System.out.println("PathPrimary");

         :} ;
	
	PathPrimary	  ::=  	PARENTHO Path PARENTHC
         {: 
			System.out.println("PathPrimary");

         :};

	PathNegatedPropertySet	  ::=  	PathOneInPropertySet 
         {: 
			System.out.println("PathNegatedPropertySet");

         :} ;  
	PathNegatedPropertySet	  ::=  	PARENTHO PathOneInPropertySetSQ PARENTHC
         {: 
			System.out.println("PathNegatedPropertySet");

         :} ;  
	PathOneInPropertySetSQ    ::=   PathOneInPropertySet PathOneInPropertySetS
         {: 
			System.out.println("PathOneInPropertySetSQ");

         :} |;  
         
    PathOneInPropertySetS  ::= PathOneInPropertySets
	    |
	    %prec PIPE;
         
	PathOneInPropertySets     ::=  PIPE PathOneInPropertySet
         {: 
			System.out.println("PathOneInPropertySetS");

         :} 
         |
          PathOneInPropertySet PIPE PathOneInPropertySets
         {: 
			System.out.println("PathOneInPropertySetS");

         :} ;  

	PathOneInPropertySet	  ::=  	iri iri
         {: 
			System.out.println("PathOneInPropertySet");
         :} ;
		 
	PathOneInPropertySet	  ::=  	iri ISA
         {: 
			System.out.println("PathOneInPropertySet");

         :} ;
		 
	PathOneInPropertySet	  ::=  	ISA iri
         {: 
			System.out.println("PathOneInPropertySet");

         :} ;
		 
	PathOneInPropertySet	  ::=  	ISA ISA
         {: 
			System.out.println("PathOneInPropertySet");

         :} ;
		 
	PathOneInPropertySet	  ::=   CARET iri
         {: 
			System.out.println("PathOneInPropertySet");

         :} ;
		 
	PathOneInPropertySet	  ::=  	CARET ISA
         {: 
			System.out.println("PathOneInPropertySet");

         :} ;
	/*	 ERROR IN THE W3C GRAMMAR : non terminal Integer is not reacheable
  	Integer	  ::=  	INTEGER
         {: 

         :} ;  

*/
  	TriplesNode	  ::=  	Collection
         {: 
			System.out.println("TriplesNode");

         :} ;

	TriplesNode	  ::=  	BlankNodePropertyList
         {: 
			System.out.println("TriplesNode");

         :} ;

	BlankNodePropertyList	  ::=  	SBRACKETO PropertyListNotEmpty SBRACKETC
         {: 
			System.out.println("BlankNodePropertyList");

         :} ;  


  	TriplesNodePath	  ::=  	CollectionPath
         {: 
			System.out.println("TriplesNodePath");

         :} ;
		 
	TriplesNodePath	  ::=  	BlankNodePropertyListPath
         {: 
			System.out.println("TriplesNodePath");

         :} ;


	BlankNodePropertyListPath	  ::=  	SBRACKETO PropertyListPathNotEmpty SBRACKETC
         {: 
			System.out.println("BlankNodePropertyListPath");

         :} ;  


	Collection	  ::=  	PARENTHO GraphNodeP PARENTHC
         {: 
			System.out.println("Collection");

         :} ;  
	GraphNodeP        ::=    GraphNode
         {: 
			System.out.println("GraphNodeP");

         :} ;  
	GraphNodeP        ::=   GraphNode GraphNodeP 
         {: 
			System.out.println("GraphNodeP");

         :} ;  


	CollectionPath	  ::=  	PARENTHO GraphNodePathP PARENTHC
         {: 
			System.out.println("CollectionPath");

         :} ;  
	GraphNodePathP    ::=    GraphNodePath
         {: 
			System.out.println("GraphNodePathP");

         :} ;  
	GraphNodePathP    ::=  GraphNodePath GraphNodePathP 
         {: 
			System.out.println("GraphNodePathP");

         :} ;  


  	GraphNode	  ::=  	VarOrTerm
         {: 
			System.out.println("GraphNode");

         :} ;

	GraphNode	  ::=  	TriplesNode
         {: 
			System.out.println("GraphNode");

         :} ;

  	GraphNodePath	  ::=  	VarOrTerm:a
         {: 
         
			System.out.println("GraphNodePath: "+a.toString());
			RESULT=new FineElement(a);

         :} ;

	GraphNodePath	  ::=  	TriplesNodePath
         {: 
			System.out.println("GraphNodePath");
         

         :} ;

  	VarOrTerm	  ::=  	Var:a
         {: 
			System.out.println("VARORTERM: "+a.getContent());
			RESULT=new FineElement(a);

         :} ;
         
	
	VarOrTerm	  ::=  	GraphTerm:a
         {: 
			System.out.println("VarOrTerm: "+a.toString());
			RESULT=new FineElement(a);

         :} ;

  	VarOrIri	  ::=  	Var:a
         {: 
			System.out.println("VARORIRI: "+a.toString());

         :} ;
	
	VarOrIri	  ::=  	iri
         {: 
			System.out.println("VarOrIri");

         :} ;

  	Var	  ::=  	VAR1:v1
         {: 
            if (tempStr.contains(v1.toString())){
            
            }
            else {
            
		     	SparqlLexer scan= (SparqlLexer)CUP$SparqlCup$parser.getScanner();
				FakeError nut = new FakeError(scan.getLine(),scan.getColumn(),scan.getWord(),scan.getCurrentPos(),scan.getBuffer());
            	tempTot.add(nut);
            	tempStr.add(v1.toString());
            }
         
         	RESULT=new FineElement(v1.toString(),"VARIABLE");
			System.out.println("VAR1: "+v1.toString());
         :} ;
	
	Var	  ::=  	VAR2:v2
         {: 
         	if (tempStr.contains(v2.toString())){
            
            }
            else {
		     	SparqlLexer scan= (SparqlLexer)CUP$SparqlCup$parser.getScanner();
				FakeError nut = new FakeError(scan.getLine(),scan.getColumn(),scan.getWord(),scan.getCurrentPos(),scan.getBuffer());
            	tempTot.add(nut);
            	tempStr.add(v2.toString());
            }
         	RESULT=new FineElement(v2.toString(),"VARIABLE");
			System.out.println("VAR2: "+v2.toString());

         :} ;  

  	GraphTerm	  ::=  	iri:a
         {: 
			System.out.println("GraphTerm "+a.toString());
			RESULT=new FineElement(a);

         :} ;
		 
	GraphTerm	  ::=  	RDFLiteral:a
         {: 
			System.out.println("GraphTerm: "+a.toString());
			RESULT=new FineElement(a);

         :} ;
		 
	GraphTerm	  ::=  	NumericLiteral:a
         {: 
			System.out.println("GraphTerm: "+a.toString());
			RESULT=new FineElement(a);

         :} ;
		 
	GraphTerm	  ::=  	BooleanLiteral
         {: 
			System.out.println("GraphTerm");

         :} ;
		 
	GraphTerm	  ::=  	BlankNode
         {: 
			System.out.println("GraphTerm");

         :} ;
		 
	GraphTerm	  ::=  	NIL
         {: 
			System.out.println("GraphTerm");

         :} ;


  	Expression	  ::=  	ConditionalOrExpression
         {: 
			System.out.println("Expression");

         :} ;  


	ConditionalOrExpression	  ::=  	ConditionalAndExpression ConditionalAndExpressionS
         {: 
			System.out.println("ConditionalOrExpression");

         :} ;  
         
    ConditionalAndExpressionS  ::= ConditionalAndExpressions
    |
    %prec DOUBLEPIPE;
    
         
	ConditionalAndExpressions ::=  DOUBLEPIPE ConditionalAndExpression
         {: 
			System.out.println("ConditionalAndExpressionS");

         :} 
         | ConditionalAndExpression  DOUBLEPIPE ConditionalAndExpressions
         {: 
			System.out.println("ConditionalAndExpressionS");

         :} ;  


	ConditionalAndExpression	  ::=  	ValueLogical ValueLogicalS
         {: 
			System.out.println("ConditionalAndExpression");

         :} 
         ;  
         
    ValueLogicalS  ::= ValueLogicals
	    |
	    %prec DOUBLEAMPERSAND;
    
         
	ValueLogicals     ::=   DOUBLEAMPERSAND ValueLogical
         {: 
			System.out.println("ValueLogicalS");

         :} 
         |
            DOUBLEAMPERSAND ValueLogical ValueLogicals
         {: 
			System.out.println("ValueLogicalS");

         :}
         | DOUBLEAMPERSAND error:e 
         {: 
            parser.report_error("Error in ValueLogicals, error in DOUBLEAMPERSAND delimiter object", null );
			System.out.println("Error in ValueLogicals");

         :} 
         |
           DOUBLEAMPERSAND error:e  ValueLogicals
         {: 
            parser.report_error("Error in ValueLogicals, error in middle of DOUBLEAMPERSAND delimiter object", null );
			System.out.println("Error in ValueLogicals");

         :} ;   


  	ValueLogical	  ::=  	RelationalExpression
         {: 
			System.out.println("ValueLogical");

         :} ;  


	RelationalExpression	  ::=  	NumericExpression
         {: 
			System.out.println("RelationalExpression");

         :} ;
		 		 
	RelationalExpression	  ::=  	NumericExpression EQUALMARK NumericExpression
         {: 
			System.out.println("RelationalExpression");

         :} ;
	
	RelationalExpression	  ::=  	NumericExpression DIFFERENT NumericExpression
         {: 
			System.out.println("RelationalExpression");

         :} ;

	RelationalExpression	  ::=  	NumericExpression LT NumericExpression
         {: 
			System.out.println("RelationalExpression");

         :} ;

	RelationalExpression	  ::=  	NumericExpression GT NumericExpression
         {: 
			System.out.println("RelationalExpression");

         :} ;
		 
	RelationalExpression	  ::=  	NumericExpression LEQUAL NumericExpression
         {: 
			System.out.println("RelationalExpression");

         :} ;
		 
	RelationalExpression	  ::=  	NumericExpression GEQUAL NumericExpression
         {: 
			System.out.println("RelationalExpression");

         :} ;
	
	RelationalExpression	  ::=  	NumericExpression IN ExpressionList
         {: 
			System.out.println("RelationalExpression");

         :} ;
		 
	RelationalExpression	  ::=  	NOT IN ExpressionList
         {: 
			System.out.println("RelationalExpression");

         :} ;
	 
  	NumericExpression	  ::=  	AdditiveExpression
         {: 
			System.out.println("NumericExpression");

         :} ;  
    NumericLiteralBoth  ::= NumericLiteralPositive
    |
    NumericLiteralNegative
    ;
    NumericLiteralUnary ::= NumericLiteralBoth
    | NumericLiteralUnary STAR UnaryExpression
    | NumericLiteralUnary SLASH UnaryExpression
    ;

	AdditiveExpression	  ::=  	MultiplicativeExpression 
	| AdditiveExpression PLUSMARK MultiplicativeExpression
	| AdditiveExpression MINUSMARK MultiplicativeExpression
	| AdditiveExpression NumericLiteralUnary
         {: 
			System.out.println("AdditiveExpression");

         :} 
         %prec PLUSMARK;  


	MultiplicativeExpression	  ::=  	UnaryExpression 
	| MultiplicativeExpression STAR UnaryExpression
	| MultiplicativeExpression SLASH UnaryExpression
         {: 
			System.out.println("MultiplicativeExpression");

         :} 
         %prec STAR;  


  	UnaryExpression	  ::=  	  EMARK PrimaryExpression:a
         {: 
			System.out.println("UnaryExpression: "+a.toString());
			RESULT=new FineElement(a);

         :} ;

	UnaryExpression	  ::=  	  PLUSMARK PrimaryExpression:a
         {: 
			System.out.println("UnaryExpression: "+a.toString());
			RESULT=new FineElement(a);

         :} ;
		 
	UnaryExpression	  ::=  	  MINUSMARK PrimaryExpression:a
         {: 
			System.out.println("UnaryExpression: "+a.toString());
			RESULT=new FineElement(a);
         :} ;
		 
	UnaryExpression	  ::=  	  PrimaryExpression:a
         {: 
			System.out.println("UnaryExpression: "+a.toString());
			RESULT=new FineElement(a);

         :} ;
 
	PrimaryExpression	  ::=  	BrackettedExpression:a
         {: 
			System.out.println("PrimaryExpression: "+a.toString());
			RESULT=new FineElement(a);

         :} ;
		 
	PrimaryExpression	  ::=  	BuiltInCall:a
         {: 
			System.out.println("PrimaryExpression: "+a.toString());
			RESULT=new FineElement(a);

         :} ;
		 
	PrimaryExpression	  ::=  	iriOrFunction:a
         {: 
			System.out.println("PrimaryExpression: "+a.toString());
			RESULT=new FineElement(a);

         :} ;
		 
	PrimaryExpression	  ::=  	RDFLiteral:a
         {: 
			System.out.println("PrimaryExpression: "+a.toString());
			RESULT=new FineElement(a);

         :} ;
		 
	PrimaryExpression	  ::=  	NumericLiteral:a
         {: 
			System.out.println("PrimaryExpression: "+a.toString());
			RESULT=new FineElement(a);

         :} ;
		 
	PrimaryExpression	  ::=  	BooleanLiteral:a
         {: 
			System.out.println("PrimaryExpression: "+a.toString());
			RESULT=new FineElement(a);

         :} ;
		 
	PrimaryExpression	  ::=  	Var:a
         {: 
			System.out.println("PrimaryExpression: "+a.toString());
			RESULT=new FineElement(a);

         :} ;
		 
	BrackettedExpression	  ::=  	PARENTHO Expression PARENTHC
         {: 
			System.out.println("BrackettedExpression");

         :} ;  


	BuiltInCall	  ::=  	  Aggregate 
		{:	
		    SparqlLexer scan= (SparqlLexer)CUP$SparqlCup$parser.getScanner();
			FakeError nut = new FakeError(scan.getLine(),scan.getColumn(),scan.getWord(),scan.getCurrentPos(),scan.getBuffer());
			parser.report_error("BuiltInCall -&gt; Aggregate: Rule translation not supported in this Demo Version", nut );
			System.out.println("BuiltInCall -&gt; Aggregate: Rule translation not supported in this Demo Version");
         :} ;

	BuiltInCall	  ::=  	  STR PARENTHO Expression PARENTHC
		{:	
		    SparqlLexer scan= (SparqlLexer)CUP$SparqlCup$parser.getScanner();
			FakeError nut = new FakeError(scan.getLine(),scan.getColumn(),scan.getWord(),scan.getCurrentPos(),scan.getBuffer());
			parser.report_error("BuiltInCall -&gt; STR(Expression): Rule translation not supported in this Demo Version", nut );
			System.out.println("BuiltInCall -&gt; STR(Expression): Rule translation not supported in this Demo Version");
         :} ;

	BuiltInCall	  ::=  	  COALESCE ExpressionList
		{:	
		    SparqlLexer scan= (SparqlLexer)CUP$SparqlCup$parser.getScanner();
			FakeError nut = new FakeError(scan.getLine(),scan.getColumn(),scan.getWord(),scan.getCurrentPos(),scan.getBuffer());
			parser.report_error("BuiltInCall -&gt; COALESCE ExpressionList: Rule translation not supported in this Demo Version", nut );
			System.out.println("BuiltInCall -&gt; COALESCE ExpressionList: Rule translation not supported in this Demo Version");
         :} ;
		 
	BuiltInCall	  ::=  	  IF PARENTHO Expression COMMA Expression COMMA Expression PARENTHC
		{:	
		    SparqlLexer scan= (SparqlLexer)CUP$SparqlCup$parser.getScanner();
			FakeError nut = new FakeError(scan.getLine(),scan.getColumn(),scan.getWord(),scan.getCurrentPos(),scan.getBuffer());
			parser.report_error("BuiltInCall -&gt; IF (Expression,Expression,Expression): Rule translation not supported in this Demo Version", nut );
			System.out.println("BuiltInCall -&gt; IF (Expression,Expression,Expression): Rule translation not supported in this Demo Version");
         :} ;
		 
	BuiltInCall	  ::=  	  STRLANG PARENTHO Expression COMMA Expression PARENTHC
		{:	
		    SparqlLexer scan= (SparqlLexer)CUP$SparqlCup$parser.getScanner();
			FakeError nut = new FakeError(scan.getLine(),scan.getColumn(),scan.getWord(),scan.getCurrentPos(),scan.getBuffer());
			parser.report_error("BuiltInCall -&gt; STRLANG(Expression,Expression): Rule translation not supported in this Demo Version", nut );
			System.out.println("BuiltInCall -&gt; STRLANG(Expression,Expression): Rule translation not supported in this Demo Version");
         :} ;
	
	BuiltInCall	  ::=  	  STRDT PARENTHO Expression COMMA Expression PARENTHC
		{:	
		    SparqlLexer scan= (SparqlLexer)CUP$SparqlCup$parser.getScanner();
			FakeError nut = new FakeError(scan.getLine(),scan.getColumn(),scan.getWord(),scan.getCurrentPos(),scan.getBuffer());
			parser.report_error("BuiltInCall -&gt; STRDT(Expression,Expression): Rule translation not supported in this Demo Version", nut );
			System.out.println("BuiltInCall -&gt; STRDT(Expression,Expression): Rule translation not supported in this Demo Version");
         :} ;
	
	BuiltInCall	  ::=  	  SAMETERM PARENTHO Expression COMMA Expression PARENTHC
		{:	
		    SparqlLexer scan= (SparqlLexer)CUP$SparqlCup$parser.getScanner();
			FakeError nut = new FakeError(scan.getLine(),scan.getColumn(),scan.getWord(),scan.getCurrentPos(),scan.getBuffer());
			parser.report_error("BuiltInCall -&gt; SAMETERM(Expression,Expression): Rule translation not supported in this Demo Version", nut );
			System.out.println("BuiltInCall -&gt; SAMETERM(Expression,Expression): Rule translation not supported in this Demo Version");
         :} ;

	BuiltInCall	  ::=  	  ISIRI PARENTHO Expression PARENTHC
		{:	
		    SparqlLexer scan= (SparqlLexer)CUP$SparqlCup$parser.getScanner();
			FakeError nut = new FakeError(scan.getLine(),scan.getColumn(),scan.getWord(),scan.getCurrentPos(),scan.getBuffer());
			parser.report_error("BuiltInCall -&gt;  ISIRI(Expression): Rule translation not supported in this Demo Version", nut );
			System.out.println("BuiltInCall -&gt; ISIRI(Expression): Rule translation not supported in this Demo Version");
         :} ;
		 
	BuiltInCall	  ::=  	  ISURI PARENTHO Expression PARENTHC
		{:	
		    SparqlLexer scan= (SparqlLexer)CUP$SparqlCup$parser.getScanner();
			FakeError nut = new FakeError(scan.getLine(),scan.getColumn(),scan.getWord(),scan.getCurrentPos(),scan.getBuffer());
			parser.report_error("BuiltInCall -&gt;  ISURI(Expression): Rule translation not supported in this Demo Version", nut );
			System.out.println("BuiltInCall -&gt; ISURI(Expression): Rule translation not supported in this Demo Version");
         :} ;
	
	BuiltInCall	  ::=  	  ISBLANK PARENTHO Expression PARENTHC
		{:	
		    SparqlLexer scan= (SparqlLexer)CUP$SparqlCup$parser.getScanner();
			FakeError nut = new FakeError(scan.getLine(),scan.getColumn(),scan.getWord(),scan.getCurrentPos(),scan.getBuffer());
			parser.report_error("BuiltInCall -&gt; ISBLANK(Expression): Rule translation not supported in this Demo Version", nut );
			System.out.println("BuiltInCall -&gt; ISBLANK(Expression): Rule translation not supported in this Demo Version");
         :} ;
		 
	BuiltInCall	  ::=  	  ISLITERAL PARENTHO Expression PARENTHC
		{:	
		    SparqlLexer scan= (SparqlLexer)CUP$SparqlCup$parser.getScanner();
			FakeError nut = new FakeError(scan.getLine(),scan.getColumn(),scan.getWord(),scan.getCurrentPos(),scan.getBuffer());
			parser.report_error("BuiltInCall -&gt; ISLITERAL(Expression): Rule translation not supported in this Demo Version", nut );
			System.out.println("BuiltInCall -&gt; ISLITERAL(Expression): Rule translation not supported in this Demo Version");
         :} ;
		 
	BuiltInCall	  ::=  	  ISNUMERIC PARENTHO Expression PARENTHC
		{:	
		    SparqlLexer scan= (SparqlLexer)CUP$SparqlCup$parser.getScanner();
			FakeError nut = new FakeError(scan.getLine(),scan.getColumn(),scan.getWord(),scan.getCurrentPos(),scan.getBuffer());
			parser.report_error("BuiltInCall -&gt; ISNUMERIC(Expression): Rule translation not supported in this Demo Version", nut );
			System.out.println("BuiltInCall -&gt; ISNUMERIC(Expression): Rule translation not supported in this Demo Version");
         :} ;
		 
	BuiltInCall	  ::=  	  RegexExpression
		{:	
		    SparqlLexer scan= (SparqlLexer)CUP$SparqlCup$parser.getScanner();
			FakeError nut = new FakeError(scan.getLine(),scan.getColumn(),scan.getWord(),scan.getCurrentPos(),scan.getBuffer());
			parser.report_error("BuiltInCall -&gt; RegexExpression: Rule translation not supported in this Demo Version", nut );
			System.out.println("BuiltInCall -&gt; RegexExpression: Rule translation not supported in this Demo Version");
         :} ;

  	RegexExpression	  ::=  	REGEX PARENTHO Expression COMMA Expression COMMA Expression PARENTHC
         {: 
		    SparqlLexer scan= (SparqlLexer)CUP$SparqlCup$parser.getScanner();
			FakeError nut = new FakeError(scan.getLine(),scan.getColumn(),scan.getWord(),scan.getCurrentPos(),scan.getBuffer());
			parser.report_error("RegexExpression -&gt; REGEX(Expression,Expression,Expression): Rule translation not supported in this Demo Version", nut );
			System.out.println("RegexExpression -&gt; REGEX(Expression,Expression,Expression): Rule translation not supported in this Demo Version");
         :} ;

	RegexExpression	  ::=  	REGEX PARENTHO Expression COMMA Expression PARENTHC
         {: 
		    SparqlLexer scan= (SparqlLexer)CUP$SparqlCup$parser.getScanner();
			FakeError nut = new FakeError(scan.getLine(),scan.getColumn(),scan.getWord(),scan.getCurrentPos(),scan.getBuffer());
			parser.report_error("RegexExpression -&gt; REGEX(Expression,Expression): Rule translation not supported in this Demo Version", nut );
			System.out.println("RegexExpression -&gt; REGEX(Expression,Expression): Rule translation not supported in this Demo Version");
         :} ;  

  	SubstringExpression	  ::=  	SUBSTR PARENTHO Expression COMMA Expression COMMA Expression PARENTHC
         {: 
		    SparqlLexer scan= (SparqlLexer)CUP$SparqlCup$parser.getScanner();
			FakeError nut = new FakeError(scan.getLine(),scan.getColumn(),scan.getWord(),scan.getCurrentPos(),scan.getBuffer());
			parser.report_error("SubstringExpression -&gt; SUBSTR(Expression,Expression,Expression): Rule translation not supported in this Demo Version", nut );
			System.out.println("SubstringExpression -&gt; SUBSTR(Expression,Expression,Expression): Rule translation not supported in this Demo Version");
         :} ;  
		 
	SubstringExpression	  ::=  	SUBSTR PARENTHO Expression COMMA Expression PARENTHC
         {: 
		    SparqlLexer scan= (SparqlLexer)CUP$SparqlCup$parser.getScanner();
			FakeError nut = new FakeError(scan.getLine(),scan.getColumn(),scan.getWord(),scan.getCurrentPos(),scan.getBuffer());
			parser.report_error("SubstringExpression -&gt; SUBSTR(Expression,Expression): Rule translation not supported in this Demo Version", nut );
			System.out.println("SubstringExpression -&gt; SUBSTR(Expression,Expression): Rule translation not supported in this Demo Version");
         :} ;  

  	StrReplaceExpression	  ::=  	REPLACE PARENTHO Expression COMMA Expression COMMA Expression COMMA Expression PARENTHC
         {: 
		    SparqlLexer scan= (SparqlLexer)CUP$SparqlCup$parser.getScanner();
			FakeError nut = new FakeError(scan.getLine(),scan.getColumn(),scan.getWord(),scan.getCurrentPos(),scan.getBuffer());
			parser.report_error("StrReplaceExpression -&gt; REPLACE(Expression,Expression,Expression,Expression): Rule translation not supported in this Demo Version", nut );
			System.out.println("StrReplaceExpression -&gt; REPLACE(Expression,Expression,Expression,Expression): Rule translation not supported in this Demo Version");
         :} ;  

	StrReplaceExpression	  ::=  	REPLACE PARENTHO Expression COMMA Expression COMMA Expression PARENTHC
         {: 
		    SparqlLexer scan= (SparqlLexer)CUP$SparqlCup$parser.getScanner();
			FakeError nut = new FakeError(scan.getLine(),scan.getColumn(),scan.getWord(),scan.getCurrentPos(),scan.getBuffer());
			parser.report_error("StrReplaceExpression -&gt; REPLACE(Expression,Expression,Expression): Rule translation not supported in this Demo Version", nut );
			System.out.println("StrReplaceExpression -&gt; REPLACE(Expression,Expression,Expression): Rule translation not supported in this Demo Version");
         :} ;  

	Aggregate	  ::=  	  COUNT PARENTHO DISTINCTQ  STAR  PARENTHC
         {: 
		    SparqlLexer scan= (SparqlLexer)CUP$SparqlCup$parser.getScanner();
			FakeError nut = new FakeError(scan.getLine(),scan.getColumn(),scan.getWord(),scan.getCurrentPos(),scan.getBuffer());
			parser.report_error("Aggregate -&gt; COUNT(DISTINCT? *): Rule translation not supported in this Demo Version", nut );
			System.out.println("Aggregate -&gt; COUNT(DISTINCT? *): Rule translation not supported in this Demo Version");
         :} ;
	Aggregate	  ::=  	  COUNT PARENTHO DISTINCTQ  Expression  PARENTHC
         {: 
		    SparqlLexer scan= (SparqlLexer)CUP$SparqlCup$parser.getScanner();
			FakeError nut = new FakeError(scan.getLine(),scan.getColumn(),scan.getWord(),scan.getCurrentPos(),scan.getBuffer());
			parser.report_error("Aggregate -&gt; COUNT(DISTINCT? Expression): Rule translation not supported in this Demo Version", nut );
			System.out.println("Aggregate -&gt; COUNT(DISTINCT? Expression): Rule translation not supported in this Demo Version");
         :} ;
	Aggregate	  ::=  	  SUM PARENTHO DISTINCTQ Expression PARENTHC
         {: 
		    SparqlLexer scan= (SparqlLexer)CUP$SparqlCup$parser.getScanner();
			FakeError nut = new FakeError(scan.getLine(),scan.getColumn(),scan.getWord(),scan.getCurrentPos(),scan.getBuffer());
			parser.report_error("Aggregate -&gt; SUM(DISTINCT? Expression): Rule translation not supported in this Demo Version", nut );
			System.out.println("Aggregate -&gt; SUM(DISTINCT? Expression): Rule translation not supported in this Demo Version");
         :} ;
	Aggregate	  ::=  	  MIN PARENTHO DISTINCTQ Expression PARENTHC
         {: 
		    SparqlLexer scan= (SparqlLexer)CUP$SparqlCup$parser.getScanner();
			FakeError nut = new FakeError(scan.getLine(),scan.getColumn(),scan.getWord(),scan.getCurrentPos(),scan.getBuffer());
			parser.report_error("Aggregate -&gt; MIN(DISTINCT? Expression): Rule translation not supported in this Demo Version", nut );
			System.out.println("Aggregate -&gt; MIN(DISTINCT? Expression): Rule translation not supported in this Demo Version");
         :} ;
	Aggregate	  ::=  	   MAX PARENTHO DISTINCTQ Expression PARENTHC 
         {: 
		    SparqlLexer scan= (SparqlLexer)CUP$SparqlCup$parser.getScanner();
			FakeError nut = new FakeError(scan.getLine(),scan.getColumn(),scan.getWord(),scan.getCurrentPos(),scan.getBuffer());
			parser.report_error("Aggregate -&gt; MAX(DISTINCT? Expression): Rule translation not supported in this Demo Version", nut );
			System.out.println("Aggregate -&gt; MAX(DISTINCT? Expression): Rule translation not supported in this Demo Version");
         :} ;
	Aggregate	  ::=  	  AVG PARENTHO DISTINCTQ Expression PARENTHC
         {: 
		    SparqlLexer scan= (SparqlLexer)CUP$SparqlCup$parser.getScanner();
			FakeError nut = new FakeError(scan.getLine(),scan.getColumn(),scan.getWord(),scan.getCurrentPos(),scan.getBuffer());
			parser.report_error("Aggregate -&gt; AVG(DISTINCT? Expression): Rule translation not supported in this Demo Version", nut );
			System.out.println("Aggregate -&gt; AVG(DISTINCT? Expression): Rule translation not supported in this Demo Version");
			

         :} ;

	Aggregate	  ::=  	  GROUP_CONCAT PARENTHO DISTINCTQ Expression  SEMICOLON SEPARATOR EQUALMARK String  PARENTHC
         {: 
		    SparqlLexer scan= (SparqlLexer)CUP$SparqlCup$parser.getScanner();
			FakeError nut = new FakeError(scan.getLine(),scan.getColumn(),scan.getWord(),scan.getCurrentPos(),scan.getBuffer());
			parser.report_error("Aggregate -&gt;  GROUP_CONCAT(DISTINCT? Expression;SEPARATOR = String): Rule translation not supported in this Demo Version", nut );
			System.out.println("Aggregate -&gt;  GROUP_CONCAT(DISTINCT? Expression;SEPARATOR = String): Rule translation not supported in this Demo Version");
			
         :} ;
	Aggregate	  ::=  	  GROUP_CONCAT PARENTHO DISTINCTQ Expression  PARENTHC
         {: 
		    SparqlLexer scan= (SparqlLexer)CUP$SparqlCup$parser.getScanner();
			FakeError nut = new FakeError(scan.getLine(),scan.getColumn(),scan.getWord(),scan.getCurrentPos(),scan.getBuffer());
			parser.report_error("Aggregate -&gt;  GROUP_CONCAT(DISTINCT? Expression): Rule translation not supported in this Demo Version", nut );
			System.out.println("Aggregate -&gt; GROUP_CONCAT(DISTINCT? Expression): Rule translation not supported in this Demo Version");
			
         :} ;
		 




  	iriOrFunction	  ::=  	iri:a
         {: 
			System.out.println("iriOrFunction");
			System.out.println(a.toString());
			RESULT=new FineElement(a);

         :} ;

	iriOrFunction	  ::=  	iri:a ArgList
         {: 
			System.out.println("iriOrFunction");
			System.out.println(a.toString());
			RESULT=new FineElement(a);

         :} ;		 

	RDFLiteral	  ::=  	String:l 
         {: 

			System.out.println("rdfliteral "+l.toString());
			RESULT=new FineElement(l);

         :}  LANGTAG ;  
	RDFLiteral	  ::=  	String:l 
         {: 

			System.out.println("rdfliteral "+l.toString());
			RESULT=new FineElement(l);

         :}  CARETCARET iri
         {: 
			System.out.println("iriOrFunction");

         :} ;  
		 
	RDFLiteral	  ::=  	String:l
         {: 

			System.out.println("rdfliteral "+l.toString());
			RESULT=new FineElement(l);

         :}  ;
	

  	NumericLiteral	  ::=  	NumericLiteralUnsigned:a
         {: 

			System.out.println("NumericLiteral: "+a.toString());
			RESULT=new FineElement(a);

         :} ;
	
	NumericLiteral	  ::=  	NumericLiteralPositive:a
         {: 

			System.out.println("NumericLiteral: "+a.toString());
			RESULT=new FineElement(a.toString(),"WORD");
         :} ;
	
	NumericLiteral	  ::=  	NumericLiteralNegative:a
         {: 
			System.out.println("NumericLiteral: "+a.toString());
			RESULT=new FineElement(a.toString(),"WORD");

         :} ;		 

  	NumericLiteralUnsigned	  ::=  	INTEGER:a
         {: 

			System.out.println("NumericLiteralUnsigned: "+a.toString());
			RESULT=new FineElement(a.toString(),"WORD");
         :} ;

	NumericLiteralUnsigned	  ::=  	DECIMAL:a
         {: 
			System.out.println("NumericLiteralUnsigned: "+a.toString());
			RESULT=new FineElement(a.toString(),"WORD");

         :} ;

	NumericLiteralUnsigned	  ::=  	DOUBLE:a
         {: 
			System.out.println("NumericLiteralUnsigned: "+a.toString());
			RESULT=new FineElement(a.toString(),"WORD");

         :} ;		 

  	NumericLiteralPositive	  ::=  	INTEGER_POSITIVE:a
         {: 

			System.out.println("NumericLiteralPositive: "+a.toString());
			RESULT=new FineElement(a.toString(),"WORD");
         :} ;
	
	NumericLiteralPositive	  ::=  	DECIMAL_POSITIVE:a
         {: 
			System.out.println("NumericLiteralPositive: "+a.toString());
			RESULT=new FineElement(a.toString(),"WORD");

         :} ;
		 
	NumericLiteralPositive	  ::=  	DOUBLE_POSITIVE:a
         {: 

			System.out.println("NumericLiteralPositive: "+a.toString());
			RESULT=new FineElement(a.toString(),"WORD");
         :} ;
			
	NumericLiteralNegative	  ::=  	INTEGER_NEGATIVE:a
         {: 
			System.out.println("NumericLiteralNegative: "+a.toString());
			RESULT=new FineElement(a.toString(),"WORD");

         :} ;

	NumericLiteralNegative	  ::=  	DECIMAL_NEGATIVE:a
         {: 
			System.out.println("NumericLiteralNegative: "+a.toString());
			RESULT=new FineElement(a.toString(),"WORD");

         :} ;  

	NumericLiteralNegative	  ::=  	DOUBLE_NEGATIVE:a
         {: 
			System.out.println("NumericLiteralNegative: "+a.toString());
			RESULT=new FineElement(a.toString(),"WORD");

         :} ;  		 

  	BooleanLiteral	  ::=  	TRUE
         {: 

			System.out.println("BooleanLiteral TRUE");
			RESULT=new FineElement("true","WORD");
         :} ;

	BooleanLiteral	  ::=  	FALSE
         {: 

			System.out.println("BooleanLiteral FALSE");
			RESULT=new FineElement("false","WORD");
         :} ;  		 

  	String	  ::=  	STRING_LITERAL1:l
         {: 

			System.out.println(l.toString());
			RESULT=new FineElement(l.toString(),"WORD");
         :} ;  

	String	  ::=  	STRING_LITERAL2:l
         {: 

			System.out.println("literal "+l.toString());
			RESULT=new FineElement(l.toString(),"WORD");
         :} ;  
	
	String	  ::=  	STRING_LITERAL_LONG1:l
         {: 

			System.out.println(l.toString());
			RESULT=new FineElement(l.toString(),"WORD");

         :} ;  
	
	String	  ::=  	STRING_LITERAL_LONG2:l
         {: 

			System.out.println(l.toString());
			RESULT=new FineElement(l.toString(),"WORD");

         :} ;  
  	iri	  ::=  	IRIREF:a
         {: 
			System.out.println("iri: "+a.toString());
			RESULT=new FineElement(a.toString(),"WORD");
         :} ;
	iri	  ::=	PrefixedName:a
		{: 

			System.out.println(a.toString());
			RESULT=new FineElement(a);

         :} ;
  	PrefixedName	  ::=  	PNAME_LN:a
         {: 
			String PNAME_NSa = a.toString().substring(0,(a.toString().indexOf(":")+1));
            if (tempPreStr.contains(PNAME_NSa)){
            
            }
            else {
            
		     	SparqlLexer scan= (SparqlLexer)CUP$SparqlCup$parser.getScanner();
				FakeError nut = new FakeError(scan.getLine(),scan.getColumn(),scan.getWord(),scan.getCurrentPos(),scan.getBuffer());
            	tempPreTot.add(nut);
            	tempPreStr.add(PNAME_NSa);
            	System.out.println("prefix vector updated");
            }
			System.out.println(a.toString());
			RESULT=new FineElement(a.toString(),"WORD");
			
         :} ;
	PrefixedName	  ::=   PNAME_NS:a
		{: 
			
            if (tempPreStr.contains(a.toString())){
            
            }
            else {
            
		     	SparqlLexer scan= (SparqlLexer)CUP$SparqlCup$parser.getScanner();
				FakeError nut = new FakeError(scan.getLine(),scan.getColumn(),scan.getWord(),scan.getCurrentPos(),scan.getBuffer());
            	tempPreTot.add(nut);
            	tempPreStr.add(a.toString());
            	System.out.println("prefix vector updated");
            }
            
			System.out.println(a.toString());
			RESULT=new FineElement(a.toString(),"WORD");

         :} ;		
							</pre></code>
					</section>
				</section>
				

				<section id="fragments2">
					<h3>GeoSparql Functions implemented</h3>
					<ul style="font-size:0.6em;">
						<li class="fragment fade-in">
							spatial:nearby (latitude longitude radius [units])
							<p style="font-size:0.5em;">
							Returns URIs of nodes (Open Street Map URI) within a fixed distance wrt latitude and longitude specified. [ units ] can be meters (‘ m ’ o ‘ M ’), kilometers (‘ km ’ o ‘ KM ’) or miles (‘ mi ’ o ‘ MI ’).
							</p>
						</li>
						<li class="fragment fade-in">
							spatial:withinCircle (latitude longitude radius [units])
							<p style="font-size:0.5em;">
							Returns nodes within a circle with the given radius and centered in latitude e longitude.
							</p>
						</li>
						<li class="fragment fade-in">
							spatial:withinBox (latitude_min longitude_min latitude_max longitude_max )
							<p style="font-size:0.5em;">
							Returns nodes in the box computed using edges coordinates.
							</p>
						</li>
						<li class="fragment fade-in">
							spatial:within("POLYGON((PointAlat PointAlon,PointBlat PointBlon,PointClat PointClon,PointDlat PointDlon))")
							<p style="font-size:0.5em;">
							Returns nodes in the polygon area. The polygo is defined using Well Known Text (WKT) Literals.
							</p>
						</li>
</ul>
				</section>


				<section>
					<section>
						<h2>Translation</h2>
					
						<img src="img/trans1.png" style="height:8em;border:0;box-shadow:none;background:none;" alt="architecture" />
					</section>
					<section>
						<img src="img/trans2.png" style="height:8em;border:0;box-shadow:none;background:none;" alt="architecture" />
					</section>
					<section>
						<img src="img/trans3.png" style="height:10em;border:0;box-shadow:none;background:none;" alt="architecture" />
					</section>
					<section>
						<img src="img/trans4.png" style="height:14em;border:0;box-shadow:none;background:none;" alt="architecture" />
					</section>
					<section>
						<img src="img/trans5.png" style="height:8em;border:0;box-shadow:none;background:none;" alt="architecture" />
					</section>
					<section>
						<img src="img/trans6.png" style="height:14em;border:0;box-shadow:none;background:none;" alt="architecture" />
					</section>
				</section>
				<section>
					<section>
						<h2>Results</h2>
<pre><code style="font-size:0.5em;">
PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt; 
PREFIX lgdo: &lt;http://linkedgeodata.org/ontology/&gt; 
PREFIX spatial: &lt;http://jena.apache.org/spatial#&gt; 
PREFIX geo: &lt;http://www.w3.org/2003/01/geo/wgs84_pos#&gt; 
PREFIX losm: &lt;http://sisinflab.poliba.it/semanticweb/lod/losm/ontology/&gt; 
#Obtain OSM URI, latitude and longitude of nodes named "Sisinf Lab" 
SELECT ?link ?lat ?lon
WHERE  {  
   ?link rdfs:label "Sisinf Lab" .  
   ?link geo:lat ?lat .
   ?link geo:long ?lon.
}
</pre></code>
					</section>
					<section>
						<h2>text</h2>
<pre><code style="font-size:0.5em;">
*********************************** 
Risultato numero: 0 
*** ?lon 16.8778234 
*** ?link http://www.openstreetmap.org/node/3634102627 
*** ?lat 41.1095222 
*********************************** 
</pre></code>
					</section>
					<section>
						<h2>html</h2>
<pre><code style="font-size:0.5em;">

&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;table class="sparql" border="1"&gt;
&lt;tr&gt;
&lt;th&gt;lon&lt;/th&gt;
&lt;th&gt;link&lt;/th&gt;
&lt;th&gt;lat&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;16.8778234&lt;/th&gt;
&lt;th&gt;&lt;a href="http://www.openstreetmap.org/node/3634102627" target=_blank &gt;http://www.openstreetmap.org/node/3634102627&lt;/a&gt;&lt;/th&gt;
&lt;th&gt;41.1095222&lt;/th&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre></code>
					</section>
					<section>
						<h2>xml</h2>
<pre><code style="font-size:0.5em;">
&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
 &lt;sparql xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.w3.org/2005/sparql-results#" xsi:schemaLocation="http://www.w3.org/2001/sw/DataAccess/rf1/result2.xsd"&gt;
  &lt;head&gt;
   &lt;variable name="lon"/&gt;
   &lt;variable name="link"/&gt;
   &lt;variable name="lat"/&gt;
  &lt;/head&gt;
  &lt;results distinct="true" ordered="false"&gt;
   &lt;result&gt;
    &lt;binding name="lon"&gt;
     &lt;literal&gt;16.8778234&lt;/literal&gt;
    &lt;/binding&gt;
    &lt;binding name="link"&gt;
     &lt;uri&gt;http://www.openstreetmap.org/node/3634102627&lt;/uri&gt;
    &lt;/binding&gt;
    &lt;binding name="lat"&gt;
     &lt;literal&gt;41.1095222&lt;/literal&gt;
    &lt;/binding&gt;
   &lt;/result&gt;
  &lt;/results&gt;
 &lt;/sparql&gt;
</pre></code>
					</section>
					<section>
						<h2>json</h2>
<pre><code style="font-size:0.5em;">
{ 
  "head" : {
      "link" : [ ] ,
      "vars" : [ 
          "lon" ,
          "link" ,
          "lat"
        ]
    } ,
  "results" : {
      "distinct" : "true" ,
      "ordered" : "false" ,
      "bindings" : [ 
          { 
            "lon" : {
                "type" : "literal" ,
                "value" : "16.8778234"
              } ,
            "link" : {
                "type" : "uri" ,
                "value" : "http://www.openstreetmap.org/node/3634102627"
              } ,
            "lat" : {
                "type" : "literal" ,
                "value" : "41.1095222"
              }
          }
        ]
    }
}
</pre></code>
					</section>
				</section>	

				<section>

					<section>
						<h2>Peg.js</h2>
						<ul style="font-size:0.7em;">
						<li>Parser Generator for JavaScritpt</li>
						<li>Use <b>P</b>arsing <b>E</b>xpression <b>G</b>rammars (PEG)</li>
						<li>PEGs are not ambiguos</li>
						<li>PEGs don't express left recursion</li>
						</ul>
						
						<br />
						<a href="#" class="navigate-down">
							<img width="17" style="border:0;box-shadow:none;background:none;" height="23" data-src="https://s3.amazonaws.com/hakim-static/reveal-js/arrow.png" alt="Down arrow">
						</a>
					</section>
					<section>
						<h2>Grammar</h2>
						<div style="font-size:0.4em;
    display: block;
    position: relative;
    //width: 50em; 
    height: 25em;
    margin: 20px auto;
    text-align: left;
    font-family: monospace;
    line-height: 1.2em;
    word-wrap: break-word;
    overflow: auto;
    box-shadow: 0px 0px 6px rgba(0, 0, 0, 0.3);
    background: #3F3F3F;
    color: #DCDCDC;" class="">
<table><tr><td>DOCUMENT</td><td>=</td><td>SPARQL</td></tr>
<tr><td>SPARQL</td><td>=</td><td>QueryUnit</td></tr>
<tr><td>QueryUnit</td><td>=</td><td>Query</td></tr>
<tr><td>Query </td><td>=</td><td>Prologue SelectQuery  </td></tr>
<tr><td>Prologue </td><td>=</td><td>(BaseDecl / PrefixDecl)* </td></tr>
<tr><td>BaseDecl </td><td>=</td><td>WS* (BASE) WS* IRI_REF </td></tr>
<tr><td>PrefixDecl</td><td>=</td><td>WS* (PREFIX)  WS* PNAME_NS  WS* IRI_REF</td></tr>
<tr><td>SelectQuery </td><td>=</td><td>SelectClause WS* WhereClause WS* SolutionModifier </td></tr>
<tr><td>SubSelect </td><td>=</td><td>SelectClause WS* WhereClause WS* SolutionModifier </td></tr>
<tr><td>SelectClause </td><td>=</td><td>WS* (SELECT) WS* ( (DISTINCT) )? WS* ( ( ( WS* Var WS* ) / ( WS* '(' WS* Expression WS* (AS) WS* Var WS* ')' WS* ) )+ / ( WS* '*' WS* )  )</td></tr>
<tr><td>WhereClause </td><td>=</td><td>((WHERE))? WS* GroupGraphPattern WS* </td></tr>
<tr><td>SolutionModifier </td><td>=</td><td> OrderClause? LimitOffsetClauses?</td></tr>
<tr><td>OrderClause </td><td>=</td><td>(ORDER) WS* (BY) WS* OrderCondition+ WS*</td></tr>
<tr><td>OrderCondition</td><td>=</td><td>( ( ASC / DESC ) WS* BrackettedExpression WS* ) / (Constraint / Var)</td></tr>
<tr><td>LimitOffsetClauses </td><td>=</td><td>( LimitClause OffsetClause? / OffsetClause LimitClause? ) </td></tr>
<tr><td>LimitClause </td><td>=</td><td>(LIMIT) WS* INTEGER WS* </td></tr>
<tr><td>OffsetClause </td><td>=</td><td>(OFFSET) WS* INTEGER WS* </td></tr>
<tr><td>GroupGraphPattern</td><td>=</td><td>'{' WS* SubSelect  WS* '}' / '{' WS* GroupGraphPatternSub WS* '}' </td></tr>
<tr><td>GroupGraphPatternSub</td><td>=</td><td>TriplesBlock? WS* ( GraphPatternNotTriples WS* '.'? WS* TriplesBlock? )*</td></tr>
<tr><td>TriplesBlock</td><td>=</td><td>TriplesSameSubjectPath (WS*  '.' TriplesBlock? )? </td></tr>
<tr><td>GraphPatternNotTriples </td><td>=</td><td>GroupOrUnionGraphPattern / Filter</td></tr>
<tr><td>GroupOrUnionGraphPattern</td><td>=</td><td>GroupGraphPattern ( WS* (UNION) WS* GroupGraphPattern )* </td></tr>
<tr><td>Filter</td><td>=</td><td>WS* (FILTER) WS* Constraint </td></tr>
<tr><td>Constraint</td><td>=</td><td>BrackettedExpression / BuiltInCall / FunctionCall</td></tr>
<tr><td>FunctionCall</td><td>=</td><td>IRIref ArgList </td></tr>
<tr><td>ArgList</td><td>=</td><td>NIL / '(' (DISTINCT)? Expression ( ',' Expression)* ')' </td></tr>
<tr><td>ExpressionList</td><td>=</td><td>NIL / '(' ( Expression) ( ',' ( Expression))* ')' </td></tr>
<tr><td>PropertyListPathNotEmpty</td><td>=</td><td>(VerbPath / VerbSimple) WS* ( ObjectListPath / ParameterList) ( WS* ';' WS* ( (VerbPath / VerbSimple) WS* ObjectList)? )* </td></tr>
<tr><td>PropertyListNotEmpty</td><td>=</td><td>Verb WS* ObjectList ( WS* ';' WS* ( Verb WS* ObjectList )? )* </td></tr>
<tr><td>ObjectListPath</td><td>=</td><td>ObjectPath WS* (',' WS* ObjectPath)* </td></tr>
<tr><td>ObjectList </td><td>=</td><td>Object WS* ( ',' WS* Object )* </td></tr>
<tr><td>ObjectPath</td><td>=</td><td>GraphNodePath</td></tr>
<tr><td>Object</td><td>=</td><td>GraphNode</td></tr>
<tr><td>Verb</td><td>=</td><td>VarOrIRIref / 'a'</td></tr>
<tr><td>TriplesSameSubjectPath</td><td>=</td><td>WS* VarOrTerm WS* PropertyListPathNotEmpty / WS* TriplesNodePath WS* PropertyListPath</td></tr>
<tr><td>PropertyListPath </td><td>=</td><td>PropertyListPathNotEmpty?</td></tr>
<tr><td>ParameterList</td><td>=</td><td>( Parameter* )</td></tr>
<tr><td>Parameter</td><td>=</td><td>NumericLiteral / Var / String </td></tr>
<tr><td>VerbPath </td><td>=</td><td>Path </td></tr>
<tr><td>VerbSimple </td><td>=</td><td>Var</td></tr>
<tr><td>Path </td><td>=</td><td>PathAlternative</td></tr>
<tr><td>PathAlternative</td><td>=</td><td>PathSequence ( '|' PathSequence)* </td></tr>
<tr><td>PathSequence</td><td>=</td><td>PathEltOrInverse ( '/' PathEltOrInverse)* </td></tr>
<tr><td>PathElt</td><td>=</td><td>PathPrimary PathMod? </td></tr>
<tr><td>PathEltOrInverse</td><td>=</td><td>PathElt / '^' PathElt </td></tr>
<tr><td>PathMod </td><td>=</td><td>( '*' / '?' / '+' )</td></tr>
<tr><td>PathPrimary</td><td>=</td><td> IRIref / 'a' / '!' PathNegatedPropertySet / '(' Path ')' </td></tr>
<tr><td>PathNegatedPropertySet</td><td>=</td><td>( PathOneInPropertySet / '(' ( PathOneInPropertySet	 ('|' PathOneInPropertySet)* )? ')' )</td></tr>
<tr><td>PathOneInPropertySet</td><td>=</td><td>( IRIref / 'a' / '^' (IRIref / 'a') )</td></tr>
<tr><td>Integer </td><td>=</td><td>INTEGER</td></tr>
<tr><td>TriplesNodePath </td><td>=</td><td>CollectionPath / BlankNodePropertyListPath</td></tr>
<tr><td>TriplesNode </td><td>=</td><td>Collection / BlankNodePropertyList</td></tr>
<tr><td>BlankNodePropertyListPath</td><td>=</td><td>WS* '[' WS* PropertyListPathNotEmpty ']' WS* </td></tr>
<tr><td>BlankNodePropertyList </td><td>=</td><td>WS* '[' WS* PropertyListNotEmpty WS* ']' WS* </td></tr>
<tr><td>CollectionPath </td><td>=</td><td>WS* '(' WS* GraphNodePath+ WS* ')' WS* </td></tr>
<tr><td>Collection </td><td>=</td><td>WS* '(' WS* GraphNode+ WS* ')' WS*</td></tr>
<tr><td>GraphNodePath </td><td>=</td><td>(WS* VarOrTerm WS* / WS* TriplesNodePath WS*)</td></tr>
<tr><td>GraphNode </td><td>=</td><td>(WS* VarOrTerm WS* / WS* TriplesNode WS*) </td></tr>
<tr><td>VarOrTerm </td><td>=</td><td>(Var / GraphTerm)</td></tr>
<tr><td>VarOrIRIref </td><td>=</td><td>(Var /IRIref)</td></tr>
<tr><td>Var </td><td>=</td><td>WS* (VAR1 / VAR2) WS* </td></tr>
<tr><td>GraphTerm </td><td>=</td><td>IRIref /	RDFLiteral /	NumericLiteral /	BooleanLiteral /	BlankNode /	NIL</td></tr>
<tr><td>Expression </td><td>=</td><td>ConditionalOrExpression</td></tr>
<tr><td>ConditionalOrExpression</td><td>=</td><td>ConditionalAndExpression (WS* '||' WS* ConditionalAndExpression)* </td></tr>
<tr><td>ConditionalAndExpression </td><td>=</td><td>ValueLogical (WS* '&&' WS* ValueLogical)* </td></tr>
<tr><td>ValueLogical </td><td>=</td><td>RelationalExpression</td></tr>
<tr><td>RelationalExpression </td><td>=</td><td>NumericExpression ( WS* '=' WS* NumericExpression / WS* '!=' WS* NumericExpression / WS* '<' WS* NumericExpression / WS* '>' WS* NumericExpression / WS* '<=' WS* NumericExpression / WS* '>=' WS* NumericExpression / WS* IN WS* ExpressionList / WS* NOT WS* IN WS* ExpressionList )?</td></tr>
<tr><td>NumericExpression </td><td>=</td><td>AdditiveExpression</td></tr>
<tr><td>AdditiveExpression </td><td>=</td><td>MultiplicativeExpression ( WS* '+' WS* MultiplicativeExpression / WS* '-' WS* MultiplicativeExpression / ( NumericLiteralPositive / NumericLiteralNegative ) ( (WS* '*' WS* UnaryExpression) / (WS* '/' WS* UnaryExpression))* )* </td></tr>
<tr><td>MultiplicativeExpression</td><td>=</td><td>UnaryExpression (WS* '*' WS* UnaryExpression / WS* '/' WS* UnaryExpression)* </td></tr>
<tr><td>UnaryExpression </td><td>=</td><td>'!' WS* PrimaryExpression / '+' WS* PrimaryExpression / '-' WS* PrimaryExpression / PrimaryExpression</td></tr>
<tr><td>PrimaryExpression </td><td>=</td><td>BrackettedExpression/ BuiltInCall/ IRIrefOrFunction/ RDFLiteral / NumericLiteral / BooleanLiteral / Var </td></tr>
<tr><td>BrackettedExpression </td><td>=</td><td>'(' WS* Expression WS* ')' </td></tr>
<tr><td>BuiltInCall </td><td>=</td><td>Aggregate / (STR) WS* '(' WS* Expression WS* ')' / (COALESCE) WS* ExpressionList / (IF) WS* '(' WS* Expression WS* ',' WS* Expression WS* ',' WS* Expression WS* ')'/ (STRLANG) WS* '(' WS* Expression WS* ',' WS* Expression WS* ')' / (STRDT) WS* '(' WS* Expression WS* ',' WS* Expression WS* ')' / (ISLITERAL) WS* '(' WS* Expression WS* ')' / (ISBLANK) WS* '(' WS* Expression WS* ')' / (SAMETERM) WS*  '(' WS* Expression WS* ',' WS* Expression WS* ')' / (ISURI / ISIRI) WS* '(' WS* Expression WS* ')' / (ISNUMERIC) WS* '(' WS* Expression WS* ')' / RegexExpression</td></tr>
<tr><td>RegexExpression </td><td>=</td><td>(REGEX) WS* '(' WS* Expression WS* ',' WS* Expression WS* ( ',' WS* Expression)?  WS* ')'</td></tr>
<tr><td>SubstringExpression</td><td>=</td><td> 	(SUBSTR) WS* '(' WS* Expression WS* ',' WS* Expression WS* ( ',' WS* Expression)?  WS* ')'</td></tr>
<tr><td>StrReplaceExpression</td><td>=</td><td> (REPLACE) WS* '(' WS* Expression WS* ',' WS* Expression WS* ( ',' WS* Expression)?  WS* ')'</td></tr>
<tr><td>Aggregate </td><td>=</td><td>  (COUNT) WS* '(' WS* (DISTINCT)? WS* ('*'/Expression) WS* ')' WS* / (GROUP_CONCAT) WS* '(' WS* (DISTINCT)? WS* Expression (';' WS* SEPARATOR WS* '=' WS* String WS*)? ')' WS* / (SUM) WS* '(' WS* (DISTINCT)? WS*  Expression WS* ')' WS* / (MIN) WS* '(' WS* (DISTINCT)? WS* Expression WS* ')' WS* / (MAX) WS* '(' WS* (DISTINCT)? WS* Expression WS* ')' WS* / (AVG) WS* '(' WS* (DISTINCT)? WS* Expression WS* ')' WS* </td></tr>
<tr><td>IRIrefOrFunction </td><td>=</td><td>IRIref ArgList? </td></tr>
<tr><td>RDFLiteral </td><td>=</td><td>String ('^^' IRIref)? </td></tr>
<tr><td>NumericLiteral</td><td>=</td><td>NumericLiteralUnsigned/ NumericLiteralPositive/ NumericLiteralNegative</td></tr>
<tr><td>NumericLiteralUnsigned </td><td>=</td><td>DOUBLE/ DECIMAL/ INTEGER</td></tr>
<tr><td>NumericLiteralPositive </td><td>=</td><td>DOUBLE_POSITIVE/ DECIMAL_POSITIVE/ INTEGER_POSITIVE</td></tr>
<tr><td>NumericLiteralNegative </td><td>=</td><td>DOUBLE_NEGATIVE/ DECIMAL_NEGATIVE/ INTEGER_NEGATIVE</td></tr>
<tr><td>BooleanLiteral </td><td>=</td><td>(TRUE) / (FALSE) </td></tr>
<tr><td>String </td><td>=</td><td>STRING_LITERAL_LONG1 / STRING_LITERAL_LONG2 / STRING_LITERAL1/ STRING_LITERAL2 </td></tr>
<tr><td>IRIref </td><td>=</td><td>IRI_REF / PrefixedName </td></tr>
<tr><td>PrefixedName </td><td>=</td><td>PNAME_LN/ PNAME_NS </td></tr>
<tr><td>BlankNode </td><td>=</td><td>BLANK_NODE_LABEL / ANON </td></tr>
<tr><td>IRI_REF </td><td>=</td><td>'<'  [^<>"{}|^`\\\x00-\x20]* '>' </td></tr>
<tr><td>PNAME_NS </td><td>=</td><td>PN_PREFIX? ':' </td></tr>
<tr><td>PNAME_LN </td><td>=</td><td>PNAME_NS PN_LOCAL </td></tr>
<tr><td>BLANK_NODE_LABEL </td><td>=</td><td>'_:' ( (PN_CHARS_U) / [0-9] ) (( PN_CHARS / '.')* PN_CHARS)?</td></tr>
<tr><td>VAR1 </td><td>=</td><td>'?' VARNAME </td></tr>
<tr><td>VAR2 </td><td>=</td><td>'$' VARNAME</td></tr>
<tr><td>LANGTAG </td><td>=</td><td>'@' [a-zA-Z]+ ('-' [a-zA-Z0-9]+)*  </td></tr>
<tr><td>INTEGER </td><td>=</td><td>[0-9]+</td></tr>
<tr><td>DECIMAL </td><td>=</td><td>[0-9]* '.' [0-9]+</td></tr>
<tr><td>DOUBLE </td><td>=</td><td>[0-9]+ '.' [0-9]* EXPONENT / '.' [0-9]+ EXPONENT / [0-9]+ EXPONENT </td></tr>
<tr><td>INTEGER_POSITIVE </td><td>=</td><td>'+' INTEGER </td></tr>
<tr><td>DECIMAL_POSITIVE </td><td>=</td><td>'+' DECIMAL </td></tr>
<tr><td>DOUBLE_POSITIVE </td><td>=</td><td>'+' DOUBLE </td></tr>
<tr><td>INTEGER_NEGATIVE </td><td>=</td><td>'-' INTEGER </td></tr>
<tr><td>DECIMAL_NEGATIVE </td><td>=</td><td>'-' DECIMAL</td></tr>
<tr><td>DOUBLE_NEGATIVE </td><td>=</td><td>'-' DOUBLE</td></tr>
<tr><td>EXPONENT </td><td>=</td><td>[eE] [+-]? [0-9]+  </td></tr>
<tr><td>STRING_LITERAL1 </td><td>=</td><td> "'" ([^\u0027\u005C\u000A\u000D] / ECHAR)* "'"</td></tr>
<tr><td>STRING_LITERAL2 </td><td>=</td><td> '"' ([^\u0022\u005C\u000A\u000D] / ECHAR)* '"' </td></tr>
<tr><td>STRING_LITERAL_LONG1 </td><td>=</td><td>"'''" ([^\'\\] / ECHAR)* "'''"  </td></tr>
<tr><td>STRING_LITERAL_LONG2 </td><td>=</td><td>'"""' ([^\"\\] / ECHAR)* '"""'  </td></tr>
<tr><td>ECHAR </td><td>=</td><td>'\\' [tbnrf\\\"\']</td></tr>
<tr><td>NIL </td><td>=</td><td>'(' WS* ')' </td></tr>
<tr><td>WS</td><td>=</td><td>[\u0020]/ [\u0009]/ [\u000D]/ [\u000A]/ COMMENT</td></tr>
<tr><td>COMMENT </td><td>=</td><td>'#'[^*\n]+</td></tr>
<tr><td>ANON </td><td>=</td><td>'[' WS* ']'</td></tr>
<tr><td>PN_CHARS_BASE  </td><td>=</td><td>[A-Za-z\u00C0-\u00D6\u00DB-\u00F6\u00f8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]</td></tr>
<tr><td>PN_CHARS_U </td><td>=</td><td>PN_CHARS_BASE/ '_'</td></tr>
<tr><td>VARNAME </td><td>=</td><td>( PN_CHARS_U / [0-9] ) ( PN_CHARS_U / [0-9] / [\u00B7] / [\u0300-\u036F] / [\u203F-\u2040])* </td></tr>
<tr><td>PN_CHARS </td><td>=</td><td>PN_CHARS_U / [\-0-9\u00B7\u0300-\u036F\u203F-\u2040]</td></tr>
<tr><td>PN_PREFIX </td><td>=</td><td>PN_CHARS_BASE (PN_CHARS / '.')* </td></tr>
<tr><td>PN_LOCAL </td><td>=</td><td>(PN_CHARS_U / ':' / [0-9]  / PLX) (PN_CHARS / '.' / ':' / PLX)*  </td></tr>
<tr><td>PLX </td><td>=</td><td>PERCENT / PN_LOCAL_ESC</td></tr>
<tr><td>PERCENT </td><td>=</td><td>('%' HEX HEX)</td></tr>
<tr><td>HEX </td><td>=</td><td>[0-9] / [A-F] / [a-f]</td></tr>
<tr><td>PN_LOCAL_ESC </td><td>=</td><td>'\\' ( '_' / '~' / '.' / '-' / '!' / '$' / '&' / "'" / '(' / ')' / '*' / '+' / ',' / ';' / '=' / '/' / '?' / '#' / '@' / '%' ) </td></tr>
<tr><td>BASE</td><td>=</td><td> [bB][aA][sS][eE] </td></tr>
<tr><td>PREFIX</td><td>=</td><td> [pP][rR][eE][fF][iI][xX] </td></tr>
<tr><td>SELECT</td><td>=</td><td> [sS][eE][lL][eE][cC][tT] </td></tr>
<tr><td>CONSTRUCT</td><td>=</td><td> [cC][oO][nN][sS][tT][rR][uU][cC][tT] </td></tr>
<tr><td>DESCRIBE</td><td>=</td><td> [dD][eE][sS][cC][rR][iI][bB][eE] </td></tr>
<tr><td>ASK</td><td>=</td><td> [aA][sS][kK]</td></tr>
<tr><td>ORDER</td><td>=</td><td> [oO][rR][dD][eE][rR] </td></tr>
<tr><td>BY</td><td>=</td><td> [bB][yY] </td></tr>
<tr><td>DESC</td><td>=</td><td> [dD][eE][sS][cC] </td></tr>
<tr><td>ASC</td><td>=</td><td>[aA][sS][cC] </td></tr>
<tr><td>LIMIT</td><td>=</td><td> [lL][iI][mM][iI][tT] </td></tr>
<tr><td>OFFSET</td><td>=</td><td> [oO][fF][fF][sS][eE][tT] </td></tr>
<tr><td>DISTINCT</td><td>=</td><td> [dD][iI][sS][tT][iI][nN][cC][tT] </td></tr>
<tr><td>REDUCED</td><td>=</td><td> [rR][eE][dD][uU][cC][eE][dD] </td></tr>
<tr><td>FROM</td><td>=</td><td> [fF][rR][oO][mM] </td></tr>
<tr><td>NAMED</td><td>=</td><td> [nN][aA][mM][eE][dD] </td></tr>
<tr><td>WHERE</td><td>=</td><td> [wW][hH][eE][rR][eE] </td></tr>
<tr><td>GRAPH</td><td>=</td><td> [gG][rR][aA][pP][hH] </td></tr>
<tr><td>OPTIONAL</td><td>=</td><td> [oO][pP][tT][iI][oO][nN][aA][lL] </td></tr>
<tr><td>UNION</td><td>=</td><td> [uU][nN][iI][oO][nN] </td></tr>
<tr><td>FILTER</td><td>=</td><td> [fF][iI][lL][tT][eE][rR] </td></tr>
<tr><td>ISA</td><td>=</td><td> "a" </td></tr>
<tr><td>STR</td><td>=</td><td> [sS][tT][rR] </td></tr>
<tr><td>LANG</td><td>=</td><td> [lL][aA][nN][gG]</td></tr>
<tr><td>LANGMATCHES</td><td>=</td><td> [lL][aA][nN][gG][mM][sA][tT][cC][hH][eE][sS] </td></tr>
<tr><td>DATATYPE</td><td>=</td><td> [dD][aA][tT][aA][tT][yY][pP][eE] </td></tr>
<tr><td>BOUND</td><td>=</td><td> [bB][oO][uU][nN][dD] </td></tr>
<tr><td>SAMETERM</td><td>=</td><td> [sS][aA][mM][eE][tT][eE][rR][mM] </td></tr>
<tr><td>ISURI</td><td>=</td><td> [iI][sS][uU][rR][iI] </td></tr>
<tr><td>ISIRI</td><td>=</td><td> [iI][sS][iI][rR][iI] </td></tr>
<tr><td>ISBLANK</td><td>=</td><td> [iI][sS][bB][lL][aA][nN][kK] </td></tr>
<tr><td>ISLITERAL</td><td>=</td><td> [iI][sS][lL][iI][tT][eE][rR][aA][lL] </td></tr>
<tr><td>REGEX</td><td>=</td><td> [rR][eE][gG][eE][xX] </td></tr>
<tr><td>TRUE</td><td>=</td><td> [tT][rR][uU][eE] </td></tr>
<tr><td>FALSE</td><td>=</td><td>[fF][aA][lL][sS][eE] </td></tr>
<tr><td>NOT </td><td>=</td><td> [nN][oO][tT]</td></tr>
<tr><td>EXISTS </td><td>=</td><td> [eE][xX][iI][sS][tT][sS]</td></tr>
<tr><td>REPLACE </td><td>=</td><td> [rR][eE][pP][lL][aA][cC][eE]</td></tr>
<tr><td>AS </td><td>=</td><td> [aA][sS]</td></tr>
<tr><td>SUBSTR </td><td>=</td><td> [sS][uU][bB][sS][tT][rR]</td></tr>
<tr><td>BNODE </td><td>=</td><td> [bB][nN][oO][dD][eE]</td></tr>
<tr><td>IRI </td><td>=</td><td> [iI][rR][iI]</td></tr>
<tr><td>URI </td><td>=</td><td> [uU][rR][iI]</td></tr>
<tr><td>RAND </td><td>=</td><td> [rR][aA][nN][dD]</td></tr>
<tr><td>ABS </td><td>=</td><td> [aA][bB][sS]</td></tr>
<tr><td>CEIL </td><td>=</td><td> [cC][eE][iI][lL]</td></tr>
<tr><td>FLOOR </td><td>=</td><td> [fF][lL][oO][oO][rR]</td></tr>
<tr><td>ROUND </td><td>=</td><td> [rR][oO][uU][nN][dD]</td></tr>
<tr><td>CONCAT </td><td>=</td><td> [cC][oO][nN][cC][aA][tT]</td></tr>
<tr><td>STRLEN </td><td>=</td><td> [sS][tT][rR][lL][eE][nN]</td></tr>
<tr><td>UCASE </td><td>=</td><td> [uU][cC][aA][sS][eE]</td></tr>
<tr><td>LCASE </td><td>=</td><td> [lL][cC][aA][sS][eE]</td></tr>
<tr><td>ENCODE_FOR_URI </td><td>=</td><td> [eE][nN][cC][oO][dD][eE]"_"[fF][oO][rR]"_"[uU][rR][iI]</td></tr>
<tr><td>CONTAINS </td><td>=</td><td> [cC][oO][nN][tT][aA][iI][nN][sS]</td></tr>
<tr><td>STRSTARTS </td><td>=</td><td> [sS][tT][rR][sS][tT][aA][rR][tT][sS]</td></tr>
<tr><td>STRENDS </td><td>=</td><td> [sS][tT][rR][eE][nN][dD][sS]</td></tr>
<tr><td>STRBEFORE </td><td>=</td><td> [sS][tT][rR][bB][eE][fF][oO][rR][eE]</td></tr>
<tr><td>STRAFTER </td><td>=</td><td> [sS][tT][rR][aA][fF][tT][eE][rR]</td></tr>
<tr><td>YEAR </td><td>=</td><td> [yY][eE][aA][rR]</td></tr>
<tr><td>MONTH </td><td>=</td><td> [mM][oO][nN][tT][hH]</td></tr>
<tr><td>DAY </td><td>=</td><td> [dD][aA][yY]</td></tr>
<tr><td>HOURS </td><td>=</td><td> [hH][oO][uU][rR][sS]</td></tr>
<tr><td>MINUTES </td><td>=</td><td> [mM][iI][nN][uU][tT][eE][sS]</td></tr>
<tr><td>SECONDS </td><td>=</td><td> [sS][eE][cC][oO][nN][dD][sS]</td></tr>
<tr><td>TIMEZONE </td><td>=</td><td> [tT][iI][mM][eE][zZ][oO][nN][eE]</td></tr>
<tr><td>TZ </td><td>=</td><td> [tT][zZ]</td></tr>
<tr><td>UUID </td><td>=</td><td> [uU][uU][iI][dD]</td></tr>
<tr><td>STRUUID </td><td>=</td><td> [sS][tT][rR][uU][uU][iI][dD]</td></tr>
<tr><td>COALESCE </td><td>=</td><td> [cC][oO][aA][lL][eE][sS][cC][eE]</td></tr>
<tr><td>IF </td><td>=</td><td> [iI][fF]</td></tr>
<tr><td>STRLANG </td><td>=</td><td> [sS][tT][rR][lL][aA][nN][gG]</td></tr>
<tr><td>ISNUMERIC </td><td>=</td><td> [iI][sS][nN][uU][mM][eE][rR][iI][cC]</td></tr>
<tr><td>HAVING </td><td>=</td><td> [hH][aA][vV][iI][nN][gG]</td></tr>
<tr><td>VALUES </td><td>=</td><td> [vV][aA][lL][uU][eE][sS]</td></tr>
<tr><td>LOAD </td><td>=</td><td> [lL][oO][aA][dD]</td></tr>
<tr><td>SILENT </td><td>=</td><td> [sS][iI][lL][eE][nN][tT]</td></tr>
<tr><td>INTO </td><td>=</td><td> [iI][nN][tT][oO]</td></tr>
<tr><td>CLEAR </td><td>=</td><td> [cC][lL][eE][aA][rR]</td></tr>
<tr><td>DROP </td><td>=</td><td> [dD][rR][oO][pP]</td></tr>
<tr><td>CREATE </td><td>=</td><td> [cC][rR][eE][aA][tT][eE]</td></tr>
<tr><td>ADD </td><td>=</td><td> [aA][dD][dD]</td></tr>
<tr><td>MOVE </td><td>=</td><td> [mM][oO][vV][eE]</td></tr>
<tr><td>COPY </td><td>=</td><td> [cC][oO][pP][yY]</td></tr>
<tr><td>TO </td><td>=</td><td> [tT][oO]</td></tr>
<tr><td>INSERT </td><td>=</td><td> [iI][nN][sS][eE][rR][tT]</td></tr>
<tr><td>DATA </td><td>=</td><td> [dD][aA][tT][aA]</td></tr>
<tr><td>DELETE </td><td>=</td><td> [dD][eE][lL][eE][tT][eE]</td></tr>
<tr><td>WITH </td><td>=</td><td> [wW][iI][tT][hH]</td></tr>
<tr><td>USING </td><td>=</td><td> [uU][sS][iI][nN][gG]</td></tr>
<tr><td>ALL </td><td>=</td><td> [aA][lL][lL]</td></tr>
<tr><td>SERVICE </td><td>=</td><td> [sS][eE][rR][vV][iI][cC][eE]</td></tr>
<tr><td>BIND </td><td>=</td><td> [bB][iI][nN][dD]</td></tr>
<tr><td>UNDEF </td><td>=</td><td> [uU][nN][dD][eE][fF]</td></tr>
<tr><td>MINUS </td><td>=</td><td> [mM][iI][nN][uU][sS]</td></tr>
<tr><td>GROUP_CONCAT </td><td>=</td><td> [gG][rR][oO][uU][pP]"_"[cC][oO][nN][cC][aA][tT]</td></tr>
<tr><td>SUM </td><td>=</td><td> [sS][uU][mM]</td></tr>
<tr><td>MIN </td><td>=</td><td> [mM][iI][nN]</td></tr>
<tr><td>MAX </td><td>=</td><td> [mM][aA][xX]</td></tr>
<tr><td>COUNT </td><td>=</td><td> [cC][oO][uU][nN][tT]</td></tr>
<tr><td>SAMPLE </td><td>=</td><td> [sS][aA][mM][pP][lL][eE]</td></tr>
<tr><td>AVG </td><td>=</td><td> [aA][vV][gG]</td></tr>
<tr><td>SEPARATOR </td><td>=</td><td> [sS][eE][pP][aA][rR][aA][tT][oO][rR]</td></tr>
<tr><td>GROUP</td><td>=</td><td>[gG][rR][oO][uP]</td></tr>
<tr><td>IN</td><td>=</td><td>[iI][nN]</td></tr>
<tr><td>NOW</td><td>=</td><td>[nN][oO][wW]</td></tr>
<tr><td>STRDT</td><td>=</td><td>[sS][tT][rR][dD][tT]</td></tr></table>
</div>
					</section>
					
				</section>
				<section>
					<style>
					    #wrap { width: 27em; height: 22em; padding: 1em; overflow: hidden; }
					    #frame { width: 100%; height: 100%; border: 0; overflow: hidden;}
					    #frame {
						-ms-zoom: 0.75;
						-moz-transform: scale(0.75);
						-moz-transform-origin: 0 0;
						-o-transform: scale(0.75);
						-o-transform-origin: 0 0;
						-webkit-transform: scale(0.75);
						-webkit-transform-origin: 0 0;
					    }
					</style>
					<div id="wrap">
					<iframe id="frame" scrolling="no" src="http://sisinflab.poliba.it/semanticweb/lod/losm/demo.html"></iframe>
					</div>
				</section>
		<section>
			<h2>ERROR TESTS</h2>
			<p>The error tests are available at the following link:</p>
			<p><a target=_blank href="http://sisinflab.poliba.it/semanticweb/lod/losm/error_tests.html"> http://sisinflab.poliba.it/semanticweb/lod/losm/error_tests.html </a></p>
		</section>
		<section>
			<h2>TEST CASES</h2>
			<p>The test cases are available at the following link:</p>
			<p><a target=_blank href="http://sisinflab.poliba.it/semanticweb/lod/losm/demo.html"> http://sisinflab.poliba.it/semanticweb/lod/losm/demo.html </a></p>
		</section>
		
		<section style="text-align: left;">
			<h1>THE END</h1>
			<p>
				- <a href="http://sisinflab.poliba.it/semanticweb/lod/losm">Try the online demo</a>
			</p>
		</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'convex', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
